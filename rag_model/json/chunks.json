[
    {
        "content": "DATA STRUCTURES USING \n“C”",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 0,
            "page_label": "1"
        }
    },
    {
        "content": "DATA STRUCTURES USING \n“C”  \n \nLECTURE NOTES \nPrepared by \nDr. Subasish Mohapatra \n  \n      \n \nDepartment of Computer Science and Application \nCollege of Engineering and Technology, Bhubaneswar \nBiju Patnaik University of Technology, Odisha",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 1,
            "page_label": "2"
        }
    },
    {
        "content": "SYLLABUS \n \nBE 2106   DATA STRUCTURE     (3-0-0) \n  \nModule – I                     \nIntroduction to data structures: storage structure for arrays, sparse matrices, Stacks and \nQueues: representation and  application. Linked lists: Single linked lists, linked list \nrepresentation of stacks and Queues. Operations on polynomials, Double linked list, \ncircular list.  \n \nModule – II                                \nDynamic storage management -garbage collection and c ompaction, infix to post fix \nconversion, postfix expression evaluation. Trees: Tree terminology, Binary tree, Binary",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 2,
            "page_label": "3"
        }
    },
    {
        "content": "conversion, postfix expression evaluation. Trees: Tree terminology, Binary tree, Binary \nsearch tree, General tree, B+ tree, AVL Tree, Complete Binary Tree representation, \nTree traversals, operation on Binary tree-expression Manipulation.                  \n \nModule –III                     \nGraphs: Graph terminology, Representation of graphs, path matrix, BFS (breadth first \nsearch), DFS (depth first search), topological sorting, Warshall’s algorithm (shortest \npath algorithm.) Sortin g and Searching techniques – Bubble sort, selection sort,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 2,
            "page_label": "3"
        }
    },
    {
        "content": "path algorithm.) Sortin g and Searching techniques – Bubble sort, selection sort, \nInsertion sort, Quick sort, merge sort, Heap sort, Radix sort. Linear and binary search \nmethods, Hashing techniques and hash functions.    \n     \n  \nText Books: \n 1. Gilberg and Forouzan: “Data Structur e- A Pseudo code approach with C” by \nThomson publication    \n2. “Data structure in C” by Tanenbaum, PHI publication / Pearson publication.  \n3. Pai: ”Data Structures & Algorithms; Concepts, Techniques & Algorithms ”Tata \nMcGraw Hill.  \n    \nReference Books:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 2,
            "page_label": "3"
        }
    },
    {
        "content": "McGraw Hill.  \n    \nReference Books:  \n1. “Fundamentals of data structure in C” Horowitz, Sahani & Freed, Computer Science \nPress.  \n2. “Fundamental of Data Structure” ( Schaums Series) Tata-McGraw-Hill.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 2,
            "page_label": "3"
        }
    },
    {
        "content": "CONTENTS \n \nLecture-01 Introduction to Data structure \nLecture-02 Search Operation \nLecture-03 Sparse Matrix and its representations \nLecture-04 Stack \nLecture-05 Stack Applications \nLecture-06 Queue \nLecture-07 Linked List \nLecture-08 Polynomial List \nLecture-09 Doubly Linked List  \nLecture-10 Circular Linked List  \nLecture-11 Memory Allocation \nLecture-12 Infix to Postfix Conversion  \nLecture-13 Binary Tree \nLecture-14 Special Forms of Binary Trees \nLecture-15 Tree Traversal \nLecture-16 AVL Trees \nLecture-17 B+-tree \nLecture-18 Binary Search Tree (BST) \nLecture-19 Graphs Terminology",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 3,
            "page_label": "4"
        }
    },
    {
        "content": "Lecture-17 B+-tree \nLecture-18 Binary Search Tree (BST) \nLecture-19 Graphs Terminology \nLecture-20 Depth First Search \nLecture-21 Breadth First Search \nLecture-22 Graph representation \nLecture-23 Topological Sorting \nLecture-24 Bubble Sort \nLecture-25 Insertion Sort  \nLecture-26 Selection Sort \nLecture-27 Merge Sort  \nLecture-28 Quick sort \nLecture-29 Heap Sort \nLecture-30 Radix Sort  \nLecture-31 Binary Search \nLecture-32 Hashing \nLecture-33 Hashing Functions",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 3,
            "page_label": "4"
        }
    },
    {
        "content": "Module-1 \nLecture-01 \nIntroduction to Data structures \nIn computer terms, a data structure is a Specific way to store and organize data in a \ncomputer's memory so that these data can be  used efficiently later. Data may be \narranged in many different ways such as the logical or mathematical model for a \nparticular organization of data is termed as a data structure. The variety of a particular \ndata model depends on the two factors - \n Firstly, it must be loaded enough in structure to reflect the actual relationships of \nthe data with the real world object.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 4,
            "page_label": "5"
        }
    },
    {
        "content": "the data with the real world object. \n Secondly, the formation should be simple enough so that anyone can efficiently \nprocess the data each time it is necessary. \nCategories of Data Structure: \nThe data structure can be sub divided into major types: \n Linear Data Structure \n Non-linear Data Structure \nLinear Data Structure: \nA data structure is said to be linear if its elements combine to form any specific order. \nThere are basically two techniques of representing such linear structure within memory. \n First way is to provide the linear relationships among all the elements",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 4,
            "page_label": "5"
        }
    },
    {
        "content": " First way is to provide the linear relationships among all the elements \nrepresented by means of linear memory location. These linear structures are termed as \narrays. \n The second technique is to provide the linear relationship among all the elements \nrepresented by using the concept of pointers or links. These linear structures are \ntermed as linked lists. \nThe common examples of linear data structure are: \n Arrays \n Queues \n Stacks \n Linked lists \nNon linear Data Structure: \nThis structure is mostly used for representing data that contains a hierarchical",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 4,
            "page_label": "5"
        }
    },
    {
        "content": "This structure is mostly used for representing data that contains a hierarchical \nrelationship among various elements. \nExamples of Non Linear Data Structures are listed below: \n Graphs \n family of trees and \n table of contents \nTree: In this case, d ata often contain a hierarchical relationship among various \nelements. The data structure that reflects this relationship is termed as rooted tree \ngraph or a tree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 4,
            "page_label": "5"
        }
    },
    {
        "content": "Graph: In this case, data sometimes hold a relationship between the pairs of elements \nwhich i s not necessarily following the hierarchical structure. Such data structure is \ntermed as a Graph. \nArray is a container which can hold a fix number of items and these items should be of \nthe same type. Most of the data structures make use of arrays to implem ent their \nalgorithms. Following are the important terms to understand the concept of Array. \n Element − Each item stored in an array is called an element. \n Index − Each location of an element in an array has a numerical index, which is",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 5,
            "page_label": "6"
        }
    },
    {
        "content": " Index − Each location of an element in an array has a numerical index, which is \nused to identify the element. \nArray Representation:(Storage structure) \nArrays can be declared in various ways in different languages. For illustration, let's take \nC array declaration. \n \nArrays can be declared in various ways in different languages. For illustration, let's take \nC array declaration. \n \nAs per the above illustration, following are the important points to be considered. \n Index starts with 0. \n Array length is 10 which means it can store 10 elements.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 5,
            "page_label": "6"
        }
    },
    {
        "content": " Index starts with 0. \n Array length is 10 which means it can store 10 elements. \n Each element can be accessed via its index. For example, we can fetch an  \nelement at index 6 as 9. \nBasic Operations \nFollowing are the basic operations supported by an array. \n Traverse − print all the array elements one by one. \n Insertion − Adds an element at the given index. \n Deletion − Deletes an element at the given index. \n Search − Searches an element using the given index or by the value. \n Update − Updates an element at the given index.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 5,
            "page_label": "6"
        }
    },
    {
        "content": " Update − Updates an element at the given index. \nIn C, when an array is initialized with size, then it assigns defaults values to its \nelements in following order. \nData Type Default Value \nbool false",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 5,
            "page_label": "6"
        }
    },
    {
        "content": "char 0 \nint 0 \nfloat 0.0 \ndouble 0.0f \nvoid  \nwchar_t 0 \nInsertion Operation \nInsert operation is to ins ert one or more data elements into an array. Based on the \nrequirement, a new element can be added at the beginning, end, or any given index of \narray. \nHere, we see a practical implementation of insertion operation, where we add data at \nthe end of the array − \nAlgorithm \nLet LA be a Linear Array (unordered) with  N elements and K is a positive integer such \nthat K<=N. Following is the algorithm where ITEM is inserted into the K th position of LA \n− \n1. Start \n2. Set J = N \n3. Set N = N+1",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 6,
            "page_label": "7"
        }
    },
    {
        "content": "− \n1. Start \n2. Set J = N \n3. Set N = N+1 \n4. Repeat steps 5 and 6 while J >= K \n5. Set LA[J+1] = LA[J] \n6. Set J = J-1 \n7. Set LA[K] = ITEM \n8. Stop \nExample \nFollowing is the implementation of the above algorithm − \n Live Demo \n#include <stdio.h> \n \nmain() { \n   int LA[] = {1,3,5,7,8}; \n   int item = 10, k = 3, n = 5; \n   int i = 0, j = n; \n   printf(\"The original array elements are :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 6,
            "page_label": "7"
        }
    },
    {
        "content": "n = n + 1; \n   while( j >= k) { \n      LA[j+1] = LA[j]; \n      j = j - 1; \n   } \n   LA[k] = item; \n   printf(\"The array elements after insertion :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n} \nWhen we compile and execute the above program, it produces the following result − \nOutput \nThe original array elements are : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 5  \nLA[3] = 7  \nLA[4] = 8  \nThe array elements after insertion : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 5  \nLA[3] = 10  \nLA[4] = 7  \nLA[5] = 8  \nDeletion Operation",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 7,
            "page_label": "8"
        }
    },
    {
        "content": "LA[0] = 1  \nLA[1] = 3  \nLA[2] = 5  \nLA[3] = 10  \nLA[4] = 7  \nLA[5] = 8  \nDeletion Operation \nDeletion refers to removing an existing element from the array and re -organizing all \nelements of an array. \nAlgorithm \nConsider LA is a linear array with  N elements and  K is a positive integer such \nthat K<=N. Following is the algorithm to delete an  element available at the K th position \nof LA. \n1. Start \n2. Set J = K \n3. Repeat steps 4 and 5 while J < N \n4. Set LA[J] = LA[J + 1] \n5. Set J = J+1 \n6. Set N = N-1 \n7. Stop \nExample",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 7,
            "page_label": "8"
        }
    },
    {
        "content": "Following is the implementation of the above algorithm − \n Lve Demo \n#include <stdio.h> \n \nvoid main() { \n   int LA[] = {1,3,5,7,8}; \n   int k = 3, n = 5; \n   int i, j; \n     printf(\"The original array elements are :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n     \n   j = k; \n   while( j < n) { \n      LA[j-1] = LA[j]; \n      j = j + 1; \n   } \n   n = n -1; \n     printf(\"The array elements after deletion :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 8,
            "page_label": "9"
        }
    },
    {
        "content": "for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n} \nWhen we compile and execute the above program, it produces the following result − \nOutput \nThe original array elements are : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 5  \nLA[3] = 7  \nLA[4] = 8  \nThe array elements after deletion : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 7  \nLA[3] = 8",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 8,
            "page_label": "9"
        }
    },
    {
        "content": "Lecture-02 \nSearch Operation \nYou can perform a search for an array element based on its value or its index. \nAlgorithm \nConsider LA is a linear array with  N elements and  K is a positive integer such \nthat K<=N. Following is the algorithm to find an element with a value of ITEM using \nsequential search. \n1. Start \n2. Set J = 0 \n3. Repeat steps 4 and 5 while J < N \n4. IF LA[J] is equal ITEM THEN GOTO STEP 6 \n5. Set J = J +1 \n6. PRINT J, ITEM \n7. Stop \nExample \nFollowing is the implementation of the above algorithm − \n Live Demo \n#include <stdio.h> \n \nvoid main() { \n   int LA[] = {1,3,5,7,8};",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 9,
            "page_label": "10"
        }
    },
    {
        "content": "Live Demo \n#include <stdio.h> \n \nvoid main() { \n   int LA[] = {1,3,5,7,8}; \n   int item = 5, n = 5; \n   int i = 0, j = 0; \n      printf(\"The original array elements are :\\n\"); \n    for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n     while( j < n){ \n      if( LA[j] == item ) { \n         break; \n      } \n     j = j + 1; \n   } \n  printf(\"Found element %d at position %d\\n\", item, j+1); \n} \nWhen we compile and execute the above program, it produces the following result − \nOutput \nThe original array elements are : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 5",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 9,
            "page_label": "10"
        }
    },
    {
        "content": "LA[3] = 7  \nLA[4] = 8  \nFound element 5 at position 3 \nUpdate Operation \nUpdate operation refers to updating an existing element from the array at a given index. \nAlgorithm \nConsider LA is a linear array with  N elements and  K is a positive integer such \nthat K<=N. Following is the algorithm to update an element available at the K th position \nof LA. \n1. Start \n2. Set LA[K-1] = ITEM \n3. Stop \nExample \nFollowing is the implementation of the above algorithm − \n Live Demo \n#include <stdio.h> \n \nvoid main() { \n   int LA[] = {1,3,5,7,8}; \n   int k = 3, n = 5, item = 10; \n   int i, j;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 10,
            "page_label": "11"
        }
    },
    {
        "content": "void main() { \n   int LA[] = {1,3,5,7,8}; \n   int k = 3, n = 5, item = 10; \n   int i, j; \n     printf(\"The original array elements are :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n     \n   LA[k-1] = item; \n  printf(\"The array elements after updation :\\n\"); \n   for(i = 0; i<n; i++) { \n      printf(\"LA[%d] = %d \\n\", i, LA[i]); \n   } \n} \nWhen we compile and execute the above program, it produces the following result − \nOutput \nThe original array elements are : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 5  \nLA[3] = 7  \nLA[4] = 8",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 10,
            "page_label": "11"
        }
    },
    {
        "content": "The array elements after updation : \nLA[0] = 1  \nLA[1] = 3  \nLA[2] = 10  \nLA[3] = 7  \nLA[4] = 8",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 11,
            "page_label": "12"
        }
    },
    {
        "content": "Lecture-03 \nSparse Matrix and its representations \nA matrix is a two -dimensional data object made of m rows and n columns, therefore \nhaving total m x n values. If most of the elements of the matrix hav e 0 value, then it is \ncalled a sparse matrix. \nWhy to use Sparse Matrix instead of simple matrix ? \n Storage: There are lesser non-zero elements than zeros and thus lesser \nmemory can be used to store only those elements. \n Computing time: Computing time can be saved by logically designing a data \nstructure traversing only non-zero elements.. \nExample: \n0 0 3 0 4             \n0 0 5 7 0",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 12,
            "page_label": "13"
        }
    },
    {
        "content": "structure traversing only non-zero elements.. \nExample: \n0 0 3 0 4             \n0 0 5 7 0 \n0 0 0 0 0 \n0 2 6 0 0 \nRepresenting a sparse matrix by a 2D array leads to wastage of lots of memory as \nzeroes in the matrix are of no u se in most of the cases. So, instead of storing zeroes \nwith non-zero elements, we only store non -zero elements. This means storing non -zero \nelements with triples- (Row, Column, value). \nSparse Matrix Representations can be done in many ways following are two common \nrepresentations: \n1. Array representation \n2. Linked list representation \nMethod 1: Using Arrays",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 12,
            "page_label": "13"
        }
    },
    {
        "content": "representations: \n1. Array representation \n2. Linked list representation \nMethod 1: Using Arrays \n#include<stdio.h> \n int main() \n{ \n    // Assume 4x5 sparse matrix \n    int sparseMatrix[4][5] = \n    { \n        {0 , 0 , 3 , 0 , 4 }, \n        {0 , 0 , 5 , 7 , 0 }, \n        {0 , 0 , 0 , 0 , 0 }, \n        {0 , 2 , 6 , 0 , 0 } \n    }; \n  \n    int size = 0; \n    for (int i = 0; i < 4; i++) \n        for (int j = 0; j < 5; j++) \n            if (sparseMatrix[i][j] != 0) \n                size++; \n     int compactMatrix[3][size]; \n     // Making of new matrix",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 12,
            "page_label": "13"
        }
    },
    {
        "content": "int k = 0; \n    for (int i = 0; i < 4; i++) \n        for (int j = 0; j < 5; j++) \n            if (sparseMatrix[i][j] != 0) \n            { \n                compactMatrix[0][k] = i; \n                compactMatrix[1][k] = j; \n                compactMatrix[2][k] = sparseMatrix[i][j]; \n                k++; \n            } \n     for (int i=0; i<3; i++) \n    { \n        for (int j=0; j<size; j++) \n            printf(\"%d \", compactMatrix[i][j]); \n         printf(\"\\n\"); \n    } \n    return 0; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 13,
            "page_label": "14"
        }
    },
    {
        "content": "Lecture-04 \nSTACK \nA stack is an Abstract Data Type (ADT), commonly used in most programming languages. It is \nnamed stack as it behaves like a real -world stack, for example – a deck of cards or a pile of \nplates, etc. \n \nA real-world stack allows opera tions at one end only. For example, we can place or remove a \ncard or plate from the top of the stack only. Likewise, Stack ADT allows all data operations at \none end only. At any given time, we can only access the top element of a stack. \nThis feature makes it LIFO data structure. LIFO stands for Last -in-first-out. Here, the element",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 14,
            "page_label": "15"
        }
    },
    {
        "content": "This feature makes it LIFO data structure. LIFO stands for Last -in-first-out. Here, the element \nwhich is placed (inserted or added) last, is accessed first. In stack terminology, insertion \noperation is called PUSH operation and removal operation is called POP operation. \nStack Representation \nThe following diagram depicts a stack and its operations − \n \nA stack can be implemented by means of Array, Structure, Pointer, and Linked List. Stack can \neither be a fixed size one or it may have a sense of dynamic resizing. Here, we are going to",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 14,
            "page_label": "15"
        }
    },
    {
        "content": "either be a fixed size one or it may have a sense of dynamic resizing. Here, we are going to \nimplement stack using arrays, which makes it a fixed size stack implementation. \nBasic Operations \nStack operations may involve initializing the stack, using it and then de -initializing it. Apart from \nthese basic stuffs, a stack is used for the following two primary operations − \n push() − Pushing (storing) an element on the stack.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 14,
            "page_label": "15"
        }
    },
    {
        "content": " pop() − Removing (accessing) an element from the stack. \nWhen data is PUSHed onto stack. \nTo use a stack efficiently, we need to check the status of stack as well. For the same purpose, \nthe following functionality is added to stacks − \n peek() − get the top data element of the stack, without removing it. \n isFull() − check if stack is full. \n isEmpty() − check if stack is empty. \nAt all times, we maintain a pointer to the last PUSHed data on the stack.  As this pointer always \nrepresents the top of the stack, hence named  top. The  top pointer provides top value of the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 15,
            "page_label": "16"
        }
    },
    {
        "content": "represents the top of the stack, hence named  top. The  top pointer provides top value of the \nstack without actually removing it. \nFirst we should learn about procedures to support stack functions − \npeek() \nAlgorithm of peek() function − \nbegin procedure peek \n   return stack[top] \nend procedure \nImplementation of peek() function in C programming language − \nExample \nint peek() { \n   return stack[top]; \n} \nisfull() \nAlgorithm of isfull() function − \nbegin procedure isfull \n \n   if top equals to MAXSIZE \n      return true \n   else \n      return false \n   endif \n    \nend procedure",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 15,
            "page_label": "16"
        }
    },
    {
        "content": "return true \n   else \n      return false \n   endif \n    \nend procedure \nImplementation of isfull() function in C programming language − \nExample \nbool isfull() { \n   if(top == MAXSIZE) \n      return true; \n   else \n      return false; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 15,
            "page_label": "16"
        }
    },
    {
        "content": "isempty() \nAlgorithm of isempty() function − \nbegin procedure isempty \n \n   if top less than 1 \n      return true \n   else \n      return false \n   endif \n    \nend procedure \nImplementation of isempty() function in C programming language is slightly different. We \ninitialize top at -1, as the index in array starts from 0. So we check if the top is below zero or -1 \nto determine if the stack is empty. Here's the code − \nExample \nbool isempty() { \n   if(top == -1) \n      return true; \n   else \n      return false; \n} \nPush Operation",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 16,
            "page_label": "17"
        }
    },
    {
        "content": "if(top == -1) \n      return true; \n   else \n      return false; \n} \nPush Operation \nThe process of putti ng a new data element onto stack is known as a Push Operation. Push \noperation involves a series of steps − \n Step 1 − Checks if the stack is full. \n Step 2 − If the stack is full, produces an error and exit. \n Step 3 − If the stack is not full, increments top to point next empty space. \n Step 4 − Adds data element to the stack location, where top is pointing. \n Step 5 − Returns success.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 16,
            "page_label": "17"
        }
    },
    {
        "content": " Step 5 − Returns success. \n \nIf the linked list is used to implement the stack, then in step 3, we need to allocate space \ndynamically. \nAlgorithm for PUSH Operation \nA simple algorithm for Push operation can be derived as follows − \nbegin procedure push: stack, data \n \n   if stack is full",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 16,
            "page_label": "17"
        }
    },
    {
        "content": "return null \n   endif \n    \n   top ← top + 1 \n   stack[top] ← data \n \nend procedure \nImplementation of this algorithm in C, is very easy. See the following code − \nExample \nvoid push(int data) { \n   if(!isFull()) { \n      top = top + 1;    \n      stack[top] = data; \n   } else { \n      printf(\"Could not insert data, Stack is full.\\n\"); \n   } \n} \nPop Operation \nAccessing the content while removing  it from the stack, is known as a Pop Operation. In an \narray implementation of pop() operation, the data element is not actually removed,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 17,
            "page_label": "18"
        }
    },
    {
        "content": "array implementation of pop() operation, the data element is not actually removed, \ninstead top is decremented to a lower position in the stack to point to the next value. But in \nlinked-list implementation, pop() actually removes data element and deallocates memory space. \nA Pop operation may involve the following steps − \n Step 1 − Checks if the stack is empty. \n Step 2 − If the stack is empty, produces an error and exit. \n Step 3 − If the stack is not empty, accesses the data element at which top is pointing. \n Step 4 − Decreases the value of top by 1. \n Step 5 − Returns success.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 17,
            "page_label": "18"
        }
    },
    {
        "content": " Step 4 − Decreases the value of top by 1. \n Step 5 − Returns success. \n \nAlgorithm for Pop Operation",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 17,
            "page_label": "18"
        }
    },
    {
        "content": "A simple algorithm for Pop operation can be derived as follows − \nbegin procedure pop: stack \n \n   if stack is empty \n      return null \n   endif \n    \n   data ← stack[top] \n   top ← top - 1 \n   return data \n \nend procedure \nImplementation of this algorithm in C, is as follows − \nExample \nint pop(int data) { \n \n   if(!isempty()) { \n      data = stack[top]; \n      top = top - 1;    \n      return data; \n   } else { \n      printf(\"Could not retrieve data, Stack is empty.\\n\"); \n   } \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 18,
            "page_label": "19"
        }
    },
    {
        "content": "Lecture-05 \nStack Applications \n  \nThree applications of stacks are presented here.  These examples are central to many activities \nthat a computer must do and deserve time spent with them. \n1. Expression evaluation \n2. Backtracking (game playing, finding paths, exhaustive searching) \n3. Memory management, run-time environment for nested language features. \n  \nExpression evaluation \nIn particular we will consider arithmetic expressions.   Understand tha t there are boolean and \nlogical expressions that can be evaluated in the same way.   Control structures can also be",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 19,
            "page_label": "20"
        }
    },
    {
        "content": "logical expressions that can be evaluated in the same way.   Control structures can also be \ntreated similarly in a compiler. \nThis study of arithmetic expression evaluation is an example of problem solving where you solve \na simpler problem and then transform the actual problem to the simpler one. \nAside: The NP -Complete problem . There are a set of apparently intractable problems: finding \nthe shortest route in a graph (Traveling Salesman Problem), bin packing, linear programming, \netc. th at are similar enough that if a polynomial solution is ever found (exponential solutions",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 19,
            "page_label": "20"
        }
    },
    {
        "content": "etc. th at are similar enough that if a polynomial solution is ever found (exponential solutions \nabound) for one of these problems, then the solution can be applied to all problems. \n  \nInfix, Prefix and Postfix Notation \nWe are accustomed to write arithmetic expressions with the operation between the two \noperands: a+b or c/d.  If we write a+b*c, however, we have to apply precedence rules to avoid \nthe ambiguous evaluation (add first or multiply first?).  \nThere's no real reason to put the operation between the variables or values.  They can just as",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 19,
            "page_label": "20"
        }
    },
    {
        "content": "There's no real reason to put the operation between the variables or values.  They can just as \nwell precede or follow the operands.  You should note the advantage of prefix and postfix: the \nneed for precedence rules and parentheses are eliminated. \nInfix Prefix Postfix \na + b + a b a b + \na + b * c + a * b c a b c * + \n(a + b) * (c - d) * + a b - c d a b + c d - * \nb * b - 4 * a * c     \n40 - 3 * 5 + 1     \nPostfix expressions are easily evaluated with the aid of a stack. \n  \n  \n \nInfix, Prefix and Postfix Notation KEY \nInfix Prefix Postfix \na + b + a b a b +",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 19,
            "page_label": "20"
        }
    },
    {
        "content": "a + b * c + a * b c a b c * + \n(a + b) * (c - d) * + a b - c d a b + c d - * \nb * b - 4 * a * c - * b b  * * 4 a c b b * 4 a * c * - \n40 - 3 * 5 + 1       =       26 +  -  40  *  3  5  1 40  3  5  *  -  1  + \n  \nPostfix Evaluation Algorithm \nAssume we have a string of operands and operators, an informal, by hand process is \n1. Scan the expression left to right \n2. Skip  values or variables (operands) \n3. When an operator is found, apply the operation to the preceding two operands \n4. Replace the two operands and operator with the calculated value (three symbols are \nreplaced with one operand)",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 20,
            "page_label": "21"
        }
    },
    {
        "content": "replaced with one operand) \n5. Continue scanning until only a value remains--the result of the expression \nThe time complexity is O(n) because each operand is scanned once, and each operation is \nperformed once. \nA more formal algorithm: \ncreate a new stack \nwhile(input stream is not empty){ \n   token = getNextToken(); \n   if(token instanceof operand){ \n       push(token); \n   } else if (token instance of operator) \n       op2 = pop(); \n       op1 = pop(); \n       result = calc(token, op1, op2); \n       push(result); \n   } \n} \nreturn pop(); \nDemonstration with 2 3 4 + * 5 -",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 20,
            "page_label": "21"
        }
    },
    {
        "content": "push(result); \n   } \n} \nreturn pop(); \nDemonstration with 2 3 4 + * 5 - \n  \n  \nInfix transformation to Postfix \nThis process uses a stack as well.   We have to hold information that's expressed inside \nparentheses while scanning to find the closing ')'. We a lso have to hold information on \noperations that are of lower precedence on the stack.  The algorithm is: \n1. Create an empty stack and an empty postfix output string/stream \n2. Scan the infix input string/stream left to right \n3. If the current input token is an operand, simply append it to the output string (note the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 20,
            "page_label": "21"
        }
    },
    {
        "content": "3. If the current input token is an operand, simply append it to the output string (note the \nexamples above that the operands remain in the same order) \n4. If the current input token is an operator, pop off all operators that have equal or higher",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 20,
            "page_label": "21"
        }
    },
    {
        "content": "precedence and append them to the output string; push the operator onto the stack.  The \norder of popping is the order in the output. \n5. If the current input token is '(', push it onto the stack \n6. If the current input token is ')', pop off all operators and append them to the output string \nuntil a '(' is popped; discard the '('. \n7. If the end of the input string is found, pop all operators and append them to the output \nstring. \nThis algorithm doesn't handle errors in the input, although careful analysis of parenthesis or lack \nof parenthesis could point to such error determination.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 21,
            "page_label": "22"
        }
    },
    {
        "content": "of parenthesis could point to such error determination. \nApply the algorithm to the above expressions. \n  \nBacktracking \nBacktracking is used in algorithms in which there are steps along some path (state) from some \nstarting point to some goal.  \n Find your way through a maze.  \n Find a path from one point in a graph (roadmap) to another point.  \n Play a game in which there are moves to be made (checkers, chess).  \nIn all of these cases, there are choices to be made among a number of options.   We need some",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 21,
            "page_label": "22"
        }
    },
    {
        "content": "In all of these cases, there are choices to be made among a number of options.   We need some \nway to remember these decision points in case we want/ne ed to come back and try the \nalternative \nConsider the maze.  At a point where a choice is made, we may discover that the choice leads \nto a dead -end.  We want to retrace back to that decision point and then try the other (next) \nalternative. \nAgain, stacks can be used as part of the solution.   Recursion is another, typically more favored, \nsolution, which is actually implemented by a stack. \n  \nMemory Management",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 21,
            "page_label": "22"
        }
    },
    {
        "content": "solution, which is actually implemented by a stack. \n  \nMemory Management \nAny modern computer environment uses a stack as the primary memory management model for \na running program.  Whether it's native code (x86, Sun, VAX) or JVM, a stack is at the center of \nthe run-time environment for Java, C++, Ada, FORTRAN, etc. \nThe discussion of JVM in the text is consistent with NT, Solaris, VMS, Unix runtime \nenvironments. \nEach program that  is running in a computer system has its own memory allocation containing \nthe typical layout as shown below.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 21,
            "page_label": "22"
        }
    },
    {
        "content": "Call and return process \nWhen a method/function is called \n1. An activation record is created; its size depends on the number and size of the local \nvariables and parameters. \n2. The Base Pointer value is saved in the special location reserved for it \n3. The Program Counter value is saved in the Return Address location \n4. The Base Pointer is now reset to the new base (top of the call stack prior to the creation \nof the AR) \n5. The Program Counter is set to the location of the first bytecode of the method being \ncalled \n6. Copies the calling parameters into the Parameter region",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 22,
            "page_label": "23"
        }
    },
    {
        "content": "called \n6. Copies the calling parameters into the Parameter region \n7. Initializes local variables in the local variable region \nWhile the method executes, the local variables and parameters are simply found by adding a \nconstant associated with each variable/parameter to the Base Pointer. \nWhen a method returns \n1. Get the program counter from the activation record and replace what's in the PC \n2. Get the base pointer value from the AR and replace what's in the BP \n3. Pop the AR entirely from the stack.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 22,
            "page_label": "23"
        }
    },
    {
        "content": "Lecture-06 \nQUEUE \nQueue is an abstract data structure, somewhat similar to Stacks. Unlike stacks, a queue is open \nat both its ends. One end is always used to insert data (enqueue) and the other is used to \nremove data (dequeue). Queue follows First -In-First-Out methodology, i.e., the data item stored \nfirst will be accessed first. \n \nA real-world example of queue can be a single -lane one -way road, where the vehicle enters \nfirst, exits first. More real-world examples can be seen as queues at the ticket windows and bus-\nstops. \nQueue Representation",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 23,
            "page_label": "24"
        }
    },
    {
        "content": "stops. \nQueue Representation \nAs we now understand that in queue, we acc ess both ends for different reasons. The following \ndiagram given below tries to explain queue representation as data structure − \n \nAs in stacks, a queue can also be implemented using Arrays, Linked -lists, Pointers and \nStructures. For the sake of simplicity, we shall implement queues using one-dimensional array. \nBasic Operations \nQueue operations may involve initializing or defining the queue, utilizing it, and then completely",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 23,
            "page_label": "24"
        }
    },
    {
        "content": "Queue operations may involve initializing or defining the queue, utilizing it, and then completely \nerasing it from the memory. Here we shall try to understand the basic operations assoc iated \nwith queues − \n enqueue() − add (store) an item to the queue. \n dequeue() − remove (access) an item from the queue. \nFew more functions are required to make the above-mentioned queue operation efficient. These \nare − \n peek() − Gets the element at the front of the queue without removing it. \n isfull() − Checks if the queue is full. \n isempty() − Checks if the queue is empty.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 23,
            "page_label": "24"
        }
    },
    {
        "content": " isfull() − Checks if the queue is full. \n isempty() − Checks if the queue is empty. \nIn queue, we always dequeue (or access) data, pointed by  front pointer and while enqueing (or \nstoring) data in the queue we take help of rear pointer. \nLet's first learn about supportive functions of a queue − \npeek()",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 23,
            "page_label": "24"
        }
    },
    {
        "content": "This function helps to see the data at the  front of the queue. The algorithm of peek() function is \nas follows − \nAlgorithm \nbegin procedure peek \n   return queue[front] \nend procedure \nImplementation of peek() function in C programming language − \nExample \nint peek() { \n   return queue[front]; \n} \nisfull() \nAs we are using single dimension array to implement queue, we just check for the rear pointer \nto reach at MAXSIZE to determine that the qu eue is full. In case we maintain the queue in a \ncircular linked-list, the algorithm will differ. Algorithm of isfull() function − \nAlgorithm",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 24,
            "page_label": "25"
        }
    },
    {
        "content": "circular linked-list, the algorithm will differ. Algorithm of isfull() function − \nAlgorithm \nbegin procedure isfull \n \n   if rear equals to MAXSIZE \n      return true \n   else \n      return false \n   endif \n    \nend procedure \nImplementation of isfull() function in C programming language − \nExample \nbool isfull() { \n   if(rear == MAXSIZE - 1) \n      return true; \n   else \n      return false; \n} \nisempty() \nAlgorithm of isempty() function − \nAlgorithm \nbegin procedure isempty \n \n   if front is less than MIN  OR front is greater than rear \n      return true",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 24,
            "page_label": "25"
        }
    },
    {
        "content": "else \n      return false \n   endif \n    \nend procedure \nIf the value of  front is less than MIN or 0, it tells that the queue is not yet initialized, hence \nempty. \nHere's the C programming code − \nExample \nbool isempty() { \n   if(front < 0 || front > rear)  \n      return true; \n   else \n      return false; \n} \nEnqueue Operation \nQueues maintain two data pointers,  front and rear. Therefore, its operations are comparatively \ndifficult to implement than that of stacks. \nThe following steps should be taken to enqueue (insert) data into a queue − \n Step 1 − Check if the queue is full.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 25,
            "page_label": "26"
        }
    },
    {
        "content": " Step 1 − Check if the queue is full. \n Step 2 − If the queue is full, produce overflow error and exit. \n Step 3 − If the queue is not full, increment rear pointer to point the next empty space. \n Step 4 − Add data element to the queue location, where the rear is pointing. \n Step 5 − return success. \n \nSometimes, we also check to see if a queue is initialized or not, to handle any unforeseen \nsituations. \nAlgorithm for enqueue operation \nprocedure enqueue(data)       \n    \n   if queue is full \n      return overflow",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 25,
            "page_label": "26"
        }
    },
    {
        "content": "endif \n    \n   rear ← rear + 1 \n   queue[rear] ← data \n   return true \n    \nend procedure \nImplementation of enqueue() in C programming language − \nExample \nint enqueue(int data)       \n   if(isfull()) \n      return 0; \n    \n   rear = rear + 1; \n   queue[rear] = data; \n    \n   return 1; \nend procedure \nDequeue Operation \nAccessing data from the queue is a process of two tasks − access the data where  front is \npointing and remove the data  after access. The following steps are taken to \nperform dequeue operation − \n Step 1 − Check if the queue is empty.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 26,
            "page_label": "27"
        }
    },
    {
        "content": "perform dequeue operation − \n Step 1 − Check if the queue is empty. \n Step 2 − If the queue is empty, produce underflow error and exit. \n Step 3 − If the queue is not empty, access the data where front is pointing. \n Step 4 − Increment front pointer to point to the next available data element. \n Step 5 − Return success. \n \nAlgorithm for dequeue operation \nprocedure dequeue",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 26,
            "page_label": "27"
        }
    },
    {
        "content": "if queue is empty \n      return underflow \n   end if \n \n   data = queue[front] \n   front ← front + 1 \n   return true \n \nend procedure \nImplementation of dequeue() in C programming language − \nExample \nint dequeue() { \n   if(isempty()) \n      return 0; \n \n   int data = queue[front]; \n   front = front + 1; \n \n   return data; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 27,
            "page_label": "28"
        }
    },
    {
        "content": "Lecture-07 \nLINKED LIST \nA linked list is a sequence of data structures, which are connected together via links. \nLinked List is a sequence of links which contains items. Each link contains a connection \nto another link. Linked list is the second most -used data structure after array. Following \nare the important terms to understand the concept of Linked List. \n Link − Each link of a linked list can store a data called an element. \n Next − Each link of a linked list contains a link to the next link called Next.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 28,
            "page_label": "29"
        }
    },
    {
        "content": " Next − Each link of a linked list contains a link to the next link called Next. \n LinkedList − A Linked List contains the connection link to the first link called \nFirst. \nLinked List Representation \nLinked list can be visualized as a chain of nodes, where every node points to the next \nnode. \n \nAs per the above illustration, following are the important points to be considered. \n Linked List contains a link element called first. \n Each link carries a data field(s) and a link field called next. \n Each link is linked with its next link using its next link.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 28,
            "page_label": "29"
        }
    },
    {
        "content": " Each link is linked with its next link using its next link. \n Last link carries a link as null to mark the end of the list. \nTypes of Linked List \nFollowing are the various types of linked list. \n Simple Linked List − Item navigation is forward only. \n Doubly Linked List − Items can be navigated forward and backward. \n Circular Linked List  − Last item contains link of the first element as next and \nthe first element has a link to the last element as previous. \nBasic Operations \nFollowing are the basic operations supported by a list.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 28,
            "page_label": "29"
        }
    },
    {
        "content": "Basic Operations \nFollowing are the basic operations supported by a list. \n Insertion − Adds an element at the beginning of the list. \n Deletion − Deletes an element at the beginning of the list. \n Display − Displays the complete list. \n Search − Searches an element using the given key. \n Delete − Deletes an element using the given key. \nInsertion Operation \nAdding a new node in linked list is a more than one step activity. We shall learn this \nwith diagrams here. First, create a node using the same structure and find the location \nwhere it has to be inserted.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 28,
            "page_label": "29"
        }
    },
    {
        "content": "Imagine that we are inserting a node  B (NewNode), between  A (LeftNode) \nand C (RightNode). Then point B.next to C − \nNewNode.next −> RightNode; \nIt should look like this − \n \nNow, the next node at the left should point to the new node. \nLeftNode.next −> NewNode; \n \nThis will put the new node in the middle of the two. The new list should look like this − \n \nSimilar steps should be taken if the node is being inserted at the beginning of the list. \nWhile inserting it at the end, the secon d last node of the list should point to the new \nnode and the new node will point to NULL.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 29,
            "page_label": "30"
        }
    },
    {
        "content": "Deletion Operation \nDeletion is also a more than one step process. We shall learn with pictorial \nrepresentation. First, locate the target node to be removed, by using searching \nalgorithms. \n \nThe left (previous) node of the target node now should point to the next node of the \ntarget node − \nLeftNode.next −> TargetNode.next; \n \nThis will remove the link that was pointing to the target node. Now, using the following \ncode, we will remove what the target node is pointing at. \nTargetNode.next −> NULL; \n \nWe need to use the deleted node. We can keep that in memory otherwise we can",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 30,
            "page_label": "31"
        }
    },
    {
        "content": "We need to use the deleted node. We can keep that in memory otherwise we can \nsimply deallocate memory and wipe off the target node completely. \n \nReverse Operation \nThis operation is a thorough one. We need to make the last node to be pointed by the \nhead node and reverse the whole linked list.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 30,
            "page_label": "31"
        }
    },
    {
        "content": "First, we traverse to the end of the list. It should be pointing to NULL. Now, we shall \nmake it point to its previous node − \n \nWe have to make sure that the last node is not the lost node. So we'll have some temp \nnode, which looks like the head node pointi ng to the last node. Now, we shall make all \nleft side nodes point to their previous nodes one by one. \n \nExcept the node (first node) pointed by the head node, all nodes should point to their \npredecessor, making them their new successor. The first node will point to NULL.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 31,
            "page_label": "32"
        }
    },
    {
        "content": "predecessor, making them their new successor. The first node will point to NULL. \n \nWe'll make the head node point to the new first node by using the temp node. \n \nThe linked list is now reversed. \nProgram: \n#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n#include <stdbool.h> \n \nstruct node { \n   int data; \n   int key; \n   struct node *next; \n};",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 31,
            "page_label": "32"
        }
    },
    {
        "content": "struct node *head = NULL; \nstruct node *current = NULL; \n \n//display the list \nvoid printList() { \n   struct node *ptr = head; \n   printf(\"\\n[ \"); \n  \n   //start from the beginning \n   while(ptr != NULL) { \n      printf(\"(%d,%d) \",ptr->key,ptr->data); \n      ptr = ptr->next; \n   } \n  \n   printf(\" ]\"); \n} \n \n//insert link at the first location \nvoid insertFirst(int key, int data) { \n   //create a link \n   struct node *link = (struct node*) malloc(sizeof(struct node)); \n  \n   link->key = key; \n   link->data = data; \n  \n   //point it to old first node \n   link->next = head;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 32,
            "page_label": "33"
        }
    },
    {
        "content": "link->data = data; \n  \n   //point it to old first node \n   link->next = head; \n  \n   //point first to new first node \n   head = link; \n} \n \n//delete first item \nstruct node* deleteFirst() { \n \n   //save reference to first link \n   struct node *tempLink = head; \n  \n   //mark next to first link as first  \n   head = head->next; \n  \n   //return the deleted link",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 32,
            "page_label": "33"
        }
    },
    {
        "content": "return tempLink; \n} \n \n//is list empty \nbool isEmpty() { \n   return head == NULL; \n} \n \nint length() { \n   int length = 0; \n   struct node *current; \n  \n   for(current = head; current != NULL; current = current->next) { \n      length++; \n   } \n  \n   return length; \n} \n \n//find a link with given key \nstruct node* find(int key) { \n \n   //start from the first link \n   struct node* current = head; \n \n   //if list is empty \n   if(head == NULL) { \n      return NULL; \n   } \n \n   //navigate through list \n   while(current->key != key) { \n  \n      //if it is last node \n      if(current->next == NULL) {",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 33,
            "page_label": "34"
        }
    },
    {
        "content": "while(current->key != key) { \n  \n      //if it is last node \n      if(current->next == NULL) { \n         return NULL; \n      } else { \n         //go to next link \n         current = current->next; \n      } \n   }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 33,
            "page_label": "34"
        }
    },
    {
        "content": "//if data found, return the current Link \n   return current; \n} \n \n//delete a link with given key \nstruct node* delete(int key) { \n \n   //start from the first link \n   struct node* current = head; \n   struct node* previous = NULL; \n  \n   //if list is empty \n   if(head == NULL) { \n      return NULL; \n   } \n \n   //navigate through list \n   while(current->key != key) { \n \n      //if it is last node \n      if(current->next == NULL) { \n         return NULL; \n      } else { \n         //store reference to current link \n         previous = current; \n         //move to next link",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 34,
            "page_label": "35"
        }
    },
    {
        "content": "previous = current; \n         //move to next link \n         current = current->next; \n      } \n   } \n \n   //found a match, update the link \n   if(current == head) { \n      //change first to point to next link \n      head = head->next; \n   } else { \n      //bypass the current link \n      previous->next = current->next; \n   }     \n  \n   return current; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 34,
            "page_label": "35"
        }
    },
    {
        "content": "void sort() { \n \n   int i, j, k, tempKey, tempData; \n   struct node *current; \n   struct node *next; \n  \n   int size = length(); \n   k = size ; \n  \n   for ( i = 0 ; i < size - 1 ; i++, k-- ) { \n      current = head; \n      next = head->next; \n   \n      for ( j = 1 ; j < k ; j++ ) {    \n \n         if ( current->data > next->data ) { \n            tempData = current->data; \n            current->data = next->data; \n            next->data = tempData; \n \n            tempKey = current->key; \n            current->key = next->key; \n            next->key = tempKey; \n         }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 35,
            "page_label": "36"
        }
    },
    {
        "content": "current->key = next->key; \n            next->key = tempKey; \n         } \n    \n         current = current->next; \n         next = next->next; \n      } \n   }    \n} \n \nvoid reverse(struct node** head_ref) { \n   struct node* prev   = NULL; \n   struct node* current = *head_ref; \n   struct node* next; \n  \n   while (current != NULL) { \n      next  = current->next; \n      current->next = prev;    \n      prev = current; \n      current = next; \n   }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 35,
            "page_label": "36"
        }
    },
    {
        "content": "*head_ref = prev; \n} \n \nvoid main() { \n   insertFirst(1,10); \n   insertFirst(2,20); \n   insertFirst(3,30); \n   insertFirst(4,1); \n   insertFirst(5,40); \n   insertFirst(6,56);  \n \n   printf(\"Original List: \");  \n  \n   //print list \n   printList(); \n \n   while(!isEmpty()) {             \n      struct node *temp = deleteFirst(); \n      printf(\"\\nDeleted value:\"); \n      printf(\"(%d,%d) \",temp->key,temp->data); \n   }   \n  \n   printf(\"\\nList after deleting all items: \"); \n   printList(); \n   insertFirst(1,10); \n   insertFirst(2,20); \n   insertFirst(3,30); \n   insertFirst(4,1);",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 36,
            "page_label": "37"
        }
    },
    {
        "content": "insertFirst(1,10); \n   insertFirst(2,20); \n   insertFirst(3,30); \n   insertFirst(4,1); \n   insertFirst(5,40); \n   insertFirst(6,56); \n    \n   printf(\"\\nRestored List: \"); \n   printList(); \n   printf(\"\\n\");   \n \n   struct node *foundLink = find(4); \n  \n   if(foundLink != NULL) { \n      printf(\"Element found: \"); \n      printf(\"(%d,%d) \",foundLink->key,foundLink->data); \n      printf(\"\\n\");",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 36,
            "page_label": "37"
        }
    },
    {
        "content": "} else { \n      printf(\"Element not found.\"); \n   } \n \n   delete(4); \n   printf(\"List after deleting an item: \"); \n   printList(); \n   printf(\"\\n\"); \n   foundLink = find(4); \n  \n   if(foundLink != NULL) { \n      printf(\"Element found: \"); \n      printf(\"(%d,%d) \",foundLink->key,foundLink->data); \n      printf(\"\\n\"); \n   } else { \n      printf(\"Element not found.\"); \n   } \n  \n   printf(\"\\n\"); \n   sort(); \n  \n   printf(\"List after sorting the data: \"); \n   printList(); \n  \n   reverse(&head); \n   printf(\"\\nList after reversing the data: \"); \n   printList(); \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 37,
            "page_label": "38"
        }
    },
    {
        "content": "reverse(&head); \n   printf(\"\\nList after reversing the data: \"); \n   printList(); \n} \nIf we compile and run the above program, it will produce the following result − \nOutput \nOriginal List:  \n[ (6,56) (5,40) (4,1) (3,30) (2,20) (1,10) ] \nDeleted value:(6,56)  \nDeleted value:(5,40)  \nDeleted value:(4,1)  \nDeleted value:(3,30)  \nDeleted value:(2,20)  \nDeleted value:(1,10)  \nList after deleting all items:  \n[ ] \nRestored List:  \n[ (6,56) (5,40) (4,1) (3,30) (2,20) (1,10) ]",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 37,
            "page_label": "38"
        }
    },
    {
        "content": "Element found: (4,1)  \nList after deleting an item:  \n[ (6,56) (5,40) (3,30) (2,20) (1,10) ] \nElement not found. \nList after sorting the data:  \n[ (1,10) (2,20) (3,30) (5,40) (6,56) ] \nList after reversing the data:  \n[ (6,56) (5,40) (3,30) (2,20) (1,10) ]",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 38,
            "page_label": "39"
        }
    },
    {
        "content": "Lecture-08 \nPolynomial List \nA polynomial p(x) is the expression in variable x which is in the form (axn + bxn-1 + …. + \njx+ k), where a, b, c …., k fall in the category of real numbers and 'n' is non negative \ninteger, which is called the degree of polynomial. \nAn important characteristics of polynomial is that each term in the polynomial \nexpression consists of two parts: \n one is the coefficient \n other is the exponent \nExample: \n10x2 + 26x, here 10 and 26 are coefficients and 2, 1 are its exponential value. \nPoints to keep in Mind while working with Polynomials:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 39,
            "page_label": "40"
        }
    },
    {
        "content": "Points to keep in Mind while working with Polynomials: \n The sign of each coefficient and exponent is stored within the coefficient and the \nexponent itself \n Additional terms having equal exponent is possible one \n The storage allocation for each term in the polynomial must be done in \nascending and descending order of their exponent \n \nRepresentation of Polynomial \nPolynomial can be represented in the various ways. These are: \n By the use of arrays \n By the use of Linked List \nRepresentation of Polynomials using Arrays",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 39,
            "page_label": "40"
        }
    },
    {
        "content": " By the use of arrays \n By the use of Linked List \nRepresentation of Polynomials using Arrays \nThere may arise some situation where you need to eva luate many polynomial \nexpressions and perform basic arithmetic operations like: addition and subtraction with \nthose numbers. For this you will have to get a way to represent those polynomials. The \nsimple way is to represent a polynomial with degree 'n' and  store the coefficient of n+1 \nterms of the polynomial in array. So every array element will consists of two values: \n Coefficient and \n Exponent",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 39,
            "page_label": "40"
        }
    },
    {
        "content": " Coefficient and \n Exponent \nRepresentation of Polynomial Using Linked Lists \nA polynomial can be thought of as an ordered list of non zero terms. Each non zero \nterm is a two tuple which holds two pieces of information:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 39,
            "page_label": "40"
        }
    },
    {
        "content": " The exponent part \n The coefficient part \nAdding two polynomials using Linked List \nGiven two polynomial numbers represented by a linked list. Write a function that add \nthese lists means add the coefficients who have same variable powers. \nExample: \nInput: \n     1st number = 5x^2 + 4x^1 + 2x^0 \n     2nd number = 5x^1 + 5x^0 \nOutput: \n        5x^2 + 9x^1 + 7x^0 \nInput: \n     1st number = 5x^3 + 4x^2 + 2x^0 \n     2nd number = 5x^1 + 5x^0 \nOutput: \n        5x^3 + 4x^2 + 5x^1 + 7x^0",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 40,
            "page_label": "41"
        }
    },
    {
        "content": "struct Node \n{ \n    int coeff; \n    int pow; \n    struct Node *next; \n}; \nvoid create_node(int x, int y, struct Node **temp) \n{ \n    struct Node *r, *z; \n    z = *temp; \n    if(z == NULL) \n    { \n        r =(struct Node*)malloc(sizeof(struct Node)); \n        r->coeff = x; \n        r->pow = y; \n        *temp = r; \n        r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n    else \n    { \n        r->coeff = x; \n        r->pow = y;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 41,
            "page_label": "42"
        }
    },
    {
        "content": "r->next = (struct Node*)malloc(sizeof(struct Node)); \n        r = r->next; \n        r->next = NULL; \n    } \n} \nvoid polyadd(struct Node *poly1, struct Node *poly2, struct Node *poly) \n{ \nwhile(poly1->next && poly2->next) \n    { \n        if(poly1->pow > poly2->pow) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        else if(poly1->pow < poly2->pow) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        } \n        else \n        {",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 42,
            "page_label": "43"
        }
    },
    {
        "content": "poly2 = poly2->next; \n        } \n        else \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff+poly2->coeff;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 42,
            "page_label": "43"
        }
    },
    {
        "content": "poly1 = poly1->next; \n            poly2 = poly2->next; \n        } \n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    } \nwhile(poly1->next || poly2->next) \n    { \n        if(poly1->next) \n        { \n            poly->pow = poly1->pow; \n            poly->coeff = poly1->coeff; \n            poly1 = poly1->next; \n        } \n        if(poly2->next) \n        { \n            poly->pow = poly2->pow; \n            poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 43,
            "page_label": "44"
        }
    },
    {
        "content": "poly->coeff = poly2->coeff; \n            poly2 = poly2->next; \n        } \n        poly->next = (struct Node *)malloc(sizeof(struct Node)); \n        poly = poly->next; \n        poly->next = NULL; \n    }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 43,
            "page_label": "44"
        }
    },
    {
        "content": "} \nvoid show(struct Node *node) \n{ \nwhile(node->next != NULL) \n    { \n    printf(\"%dx^%d\", node->coeff, node->pow); \n    node = node->next; \n    if(node->next != NULL) \n        printf(\" + \"); \n    } \n} \n int main() \n{ \n    struct Node *poly1 = NULL, *poly2 = NULL, *poly = NULL; \n    // Create first list of 5x^2 + 4x^1 + 2x^0 \n    create_node(5,2,&poly1); \n    create_node(4,1,&poly1); \n    create_node(2,0,&poly1); \n     // Create second list of 5x^1 + 5x^0 \n    create_node(5,1,&poly2); \n    create_node(5,0,&poly2); \n    printf(\"1st Number: \");  \n    show(poly1); \n     printf(\"\\n2nd Number: \");",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 44,
            "page_label": "45"
        }
    },
    {
        "content": "printf(\"1st Number: \");  \n    show(poly1); \n     printf(\"\\n2nd Number: \"); \n    show(poly2);",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 44,
            "page_label": "45"
        }
    },
    {
        "content": "poly = (struct Node *)malloc(sizeof(struct Node)); \n     // Function add two polynomial numbers \n    polyadd(poly1, poly2, poly); \n    // Display resultant List \n    printf(\"\\nAdded polynomial: \"); \n    show(poly); \n return 0; \n} \nOutput: \n1st Number: 5x^2 + 4x^1 + 2x^0 \n2nd Number: 5x^1 + 5x^0 \nAdded polynomial: 5x^2 + 9x^1 + 7x^0",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 45,
            "page_label": "46"
        }
    },
    {
        "content": "Lecture-09 \nDoubly Linked List  \nA Doubly Linked List (DLL) contains an extra pointer, typically called previous pointer, \ntogether with next pointer and data which are there in singly linked list. \n \nFollowing is representation of a DLL node in C language. \n/* Node of a doubly linked list */ \nstruct Node { \n    int data; \n    struct Node* next; // Pointer to next node in DLL \n    struct Node* prev; // Pointer to previous node in DLL \n}; \nFollowing are advantages/disadvantages of doubly linked list over singly linked list. \nAdvantages over singly linked list",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 46,
            "page_label": "47"
        }
    },
    {
        "content": "Advantages over singly linked list \n1) A DLL can be traversed in both forward and backward direction. \n2) The delete operation in DLL is more efficient if pointer to the node to be deleted is \ngiven. \n3) We can quickly insert a new node before a given node. \nIn singly linked list, to delete a node, pointer to the previous node is needed. To get \nthis previous node, sometimes the list is traversed. In DLL, we can get the previous \nnode using previous pointer. \nDisadvantages over singly linked list \n1) Every node of DLL Require extra space for an previous pointer. It is possible to",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 46,
            "page_label": "47"
        }
    },
    {
        "content": "1) Every node of DLL Require extra space for an previous pointer. It is possible to \nimplement DLL with single pointer though  \n2) All operations require an extra pointer previous to be maintained. For example, in \ninsertion, we need to modify previous pointers together with next pointers. For \nexample in following functions for insertions at different positions, we need 1 or 2 extra \nsteps to set previous pointer. \nInsertion \nA node can be added in four ways \n1) At the front of the DLL \n2) After a given node. \n3) At the end of the DLL \n4) Before a given node.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 46,
            "page_label": "47"
        }
    },
    {
        "content": "2) After a given node. \n3) At the end of the DLL \n4) Before a given node. \n1) Add a node at the front: (A 5 steps process) \nThe new node is always added before the head of the given Linked List. And newly \nadded node becomes the new head of DLL. For example if the given Linked List is",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 46,
            "page_label": "47"
        }
    },
    {
        "content": "10152025 and we add an item 5 at the front, then the Linked List becomes 510152025. \nLet us call the function that adds at the front of the l ist is push(). The push() must \nreceive a pointer to the head pointer, because push must change the head pointer to \npoint to the new node  \n \n \n2) Add a node after a given node.: (A 7 steps process) \nWe are given pointer to a node as prev_node, and the new node is inserted after the \ngiven node. \n3) Add a node at the end: (7 steps process) \nThe new node is always added after the last node of the given Linked List. For example",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 47,
            "page_label": "48"
        }
    },
    {
        "content": "The new node is always added after the last node of the given Linked List. For example \nif the given DLL is 510152025 and we add an item 30 at the end, then the DLL becomes \n51015202530. Since a Linked List is typically represented by the head of it, we have to \ntraverse the list till end and then change the next of last node to new node. \n \n4) Add a node before a given node: \nSteps \nLet the pointer to this given node be next_node and the data of the new node to be \nadded as new_data.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 47,
            "page_label": "48"
        }
    },
    {
        "content": "1. Check if the next_node is NULL or not. If it’s NULL, return from the functio n \nbecause any new node can not be added before a NULL \n2. Allocate memory for the new node, let it be called new_node \n3. Set new_node->data = new_data \n4. Set the previous pointer of this new_node as the previous node of the next_node, \nnew_node->prev = next_node->prev \n5. Set the previous pointer of the next_node as the new_node, next_node ->prev = \nnew_node \n6. Set the next pointer of this new_node as the next_node, new_node ->next = \nnext_node;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 48,
            "page_label": "49"
        }
    },
    {
        "content": "new_node \n6. Set the next pointer of this new_node as the next_node, new_node ->next = \nnext_node; \n7. If the previous node of the new_node is not NULL, then set the next pointer of \nthis previous node as new_node, new_node->prev->next = new_node",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 48,
            "page_label": "49"
        }
    },
    {
        "content": "Lecture-10 \nCircular Linked List  \nCircular linked list is a linked list where all nodes are connected to form a circle. There is \nno NULL at the end. A circular linked list can be a singly circular linked list or doubly \ncircular linked list. \n \nAdvantages of Circular Linked Lists: \n1) Any node can be a starting point. We can traverse the whole list by starting from any \npoint. We just need to stop when the first visited node is visited again. \n2) Useful for implementation of queue. Unlike  this implementation, we don’t need to",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 49,
            "page_label": "50"
        }
    },
    {
        "content": "2) Useful for implementation of queue. Unlike  this implementation, we don’t need to \nmaintain two pointers for front and rear if we use circular linked list. We can maintain a \npointer to the last inserted node and front can always be obtained as next of last. \n3) Circular lists are useful in applications to repeatedly go around the list. For example, \nwhen multiple applications are running on a PC, it is common for the operating system \nto put the running applications on a list and then to cycle through them, giving each  of",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 49,
            "page_label": "50"
        }
    },
    {
        "content": "to put the running applications on a list and then to cycle through them, giving each  of \nthem a slice of time to execute, and then making them wait while the CPU is given to \nanother application. It is convenient for the operating system to use a circular list so that \nwhen it reaches the end of the list it can cycle around to the front of the list. \n4) Circular Doubly Linked Lists are used for implementation of advanced data structures \nlike Fibonacci Heap. \nInsertion in an empty List \n \nInitially when the list is empty, last pointer will be NULL. \n \nAfter inserting a node T,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 49,
            "page_label": "50"
        }
    },
    {
        "content": "Initially when the list is empty, last pointer will be NULL. \n \nAfter inserting a node T, \n \nAfter insertion, T is the last node so pointer last points to node T. And Node T is first \nand last node, so T is pointing to itself. \nFunction to insert node in an empty List, \nstruct Node *addToEmpty(struct Node *last, int data) \n{ \n    // This function is only for empty list \n    if (last != NULL) \n      return last;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 49,
            "page_label": "50"
        }
    },
    {
        "content": "// Creating a node dynamically. \n    struct Node *last = \n          (struct Node*)malloc(sizeof(struct Node)); \n  \n    // Assigning the data. \n    last -> data = data; \n  \n    // Note : list was empty. We link single node \n    // to itself. \n    last -> next = last; \n  \n    return last; \n} \nRun on IDE \n  \nInsertion at the beginning of the list \n \nTo Insert a node at the beginning of the list, follow these step: \n1. Create a node, say T. \n2. Make T -> next = last -> next. \n3. last -> next = T. \n \nAfter insertion, \n \nFunction to insert node in the beginning of the List,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 50,
            "page_label": "51"
        }
    },
    {
        "content": "3. last -> next = T. \n \nAfter insertion, \n \nFunction to insert node in the beginning of the List, \nstruct Node *addBegin(struct Node *last, int data) \n{ \n  if (last == NULL) \n     return addToEmpty(last, data); \n  \n  // Creating a node dynamically. \n  struct Node *temp \n        = (struct Node *)malloc(sizeof(struct Node)); \n    \n  // Assigning the data. \n  temp -> data = data; \n  \n  // Adjusting the links. \n  temp -> next = last -> next; \n  last -> next = temp; \n    \n  return last;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 50,
            "page_label": "51"
        }
    },
    {
        "content": "} \n \nInsertion at the end of the list \n \nTo Insert a node at the end of the list, follow these step: \n1. Create a node, say T. \n2. Make T -> next = last -> next; \n3. last -> next = T. \n4. last = T. \n \nAfter insertion, \n \nFunction to insert node in the end of the List, \nstruct Node *addEnd(struct Node *last, int data) \n{ \n  if (last == NULL) \n     return addToEmpty(last, data); \n  \n  // Creating a node dynamically.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 51,
            "page_label": "52"
        }
    },
    {
        "content": "struct Node *temp =  \n        (struct Node *)malloc(sizeof(struct Node)); \n    \n  // Assigning the data. \n  temp -> data = data; \n  \n  // Adjusting the links. \n  temp -> next = last -> next; \n  last -> next = temp; \n  last = temp; \n    \n  return last; \n} \n \nInsertion in between the nodes \n \nTo Insert a node at the end of the list, follow these step: \n1. Create a node, say T. \n2. Search the node after which T need to be insert, say that node be P. \n3. Make T -> next = P -> next; \n4. P -> next = T. \nSuppose 12 need to be insert after node having value 10, \n \nAfter searching and insertion,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 52,
            "page_label": "53"
        }
    },
    {
        "content": "Function to insert node in the end of the List, \nstruct Node *addAfter(struct Node *last, int data, int item) \n{ \n    if (last == NULL) \n       return NULL; \n     struct Node *temp, *p; \n    p = last -> next; \n     // Searching the item. \n    do \n    { \n        if (p ->data == item) \n        { \n            temp = (struct Node *)malloc(sizeof(struct Node)); \n             // Assigning the data. \n            temp -> data = data; \n             // Adjusting the links. \n            temp -> next = p -> next; \n             // Adding newly allocated node after p. \n            p -> next = temp;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 53,
            "page_label": "54"
        }
    },
    {
        "content": "// Adding newly allocated node after p. \n            p -> next = temp; \n             // Checking for the last node. \n            if (p == last) \n                last = temp; \n             return last; \n        } \n        p = p -> next; \n    } while (p != last -> next); \n  \n    cout << item << \" not present in the list.\" << endl; \n    return last; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 53,
            "page_label": "54"
        }
    },
    {
        "content": "Module-2: \nLecture-11 \n Memory Allocation-  \nWhenever a new node is created, memory is allocated by the system. This memory is \ntaken from list of those memory locations which are free i.e. not allocated. This list is \ncalled AVAIL List. Similarly, whenever a node is deleted, the deleted space becomes \nreusable and is added to the list of unused space i.e. to AVAIL List. This unused space \ncan be used in future for memory allocation.  \nMemory allocation is of two types- \n1. Static Memory Allocation \n2. Dynamic Memory Allocation  \n \n1. Static Memory Allocation:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 54,
            "page_label": "55"
        }
    },
    {
        "content": "1. Static Memory Allocation \n2. Dynamic Memory Allocation  \n \n1. Static Memory Allocation: \nWhen memory is allocated during compilation time, it is called ‘Static Memory \nAllocation’. This memory is fixed and cannot be increased or decreased after \nallocation. If more memory is allocated than requirement, then memory is wasted. If \nless memory is al located than requirement, then program will not run successfully. \nSo exact memory requirements must be known in advance.  \n2. Dynamic Memory Allocation: \nWhen memory is allocated during run/execution time, it is called ‘Dynamic Memory",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 54,
            "page_label": "55"
        }
    },
    {
        "content": "When memory is allocated during run/execution time, it is called ‘Dynamic Memory \nAllocation’. This memory is not fixed and is allocated according to our requirements. \nThus in it there is no wastage of memory. So there is no need to know exact memory \nrequirements in advance.  \nGarbage Collection- \nWhenever a node is deleted, some memory space becomes reusable. Thi s memory \nspace should be available for future use. One way to do this is to immediately insert the \nfree space into availability list. But this method may be time consuming for the operating",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 54,
            "page_label": "55"
        }
    },
    {
        "content": "free space into availability list. But this method may be time consuming for the operating \nsystem. So another method is used which is called ‘Garbage Collect ion’. This method is \ndescribed below: In this method the OS collects the deleted space time to time onto the \navailability list. This process happens in two steps. In first step, the OS goes through all \nthe lists and tags all those cells which are currently  being used. In the second step, the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 54,
            "page_label": "55"
        }
    },
    {
        "content": "OS goes through all the lists again and collects untagged space and adds this collected \nspace to availability list. The garbage collection may occur when small amount of free \nspace is left in the system or no free space is left in the system or when CPU is idle and \nhas time to do the garbage collection.  \nCompaction \nOne preferable solution to garbage collection is compaction.  \nThe process of moving all marked nodes to one end of memory and all available \nmemory to other end  is called compaction. Algorithm which performs compaction is \ncalled compacting algorithm.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 55,
            "page_label": "56"
        }
    },
    {
        "content": "Lecture-12 \nInfix to Postfix Conversion  \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \n13 \n14 \n15 \n16 \n17 \n18 \n19 \n20 \n21 \n22 \n23 \n24 \n25 \n26 \n27 \n28 \n29 \n30 \n31 \n32 \n33 \n34 \n35 \n36 \n37 \n38 \n39 \n40 \n41 \n#include<stdio.h> \nchar stack[20]; \nint top = -1; \nvoid push(char x) \n{ \n    stack[++top] = x; \n} \n  \nchar pop() \n{ \n    if(top == -1) \n        return -1; \n    else \n        return stack[top--]; \n} \n  \nint priority(char x) \n{ \n    if(x == '(') \n        return 0; \n    if(x == '+' || x == '-') \n        return 1; \n    if(x == '*' || x == '/') \n        return 2; \n} \n  \nmain() \n{ \n    char exp[20];",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 56,
            "page_label": "57"
        }
    },
    {
        "content": "if(x == '*' || x == '/') \n        return 2; \n} \n  \nmain() \n{ \n    char exp[20]; \n    char *e, x; \n    printf(\"Enter the expression :: \"); \n    scanf(\"%s\",exp); \n    e = exp; \n    while(*e != '\\0') \n    { \n        if(isalnum(*e)) \n            printf(\"%c\",*e); \n        else if(*e == '(') \n            push(*e); \n        else if(*e == ')') \n        {",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 56,
            "page_label": "57"
        }
    },
    {
        "content": "42 \n43 \n44 \n45 \n46 \n47 \n48 \n49 \n50 \n51 \n52 \n53 \n54 \n55 \n56 \n57 \n            while((x = pop()) != '(') \n                printf(\"%c\", x); \n        } \n        else \n        { \n            while(priority(stack[top]) >= priority(*e)) \n                printf(\"%c\",pop()); \n            push(*e); \n        } \n        e++; \n    } \n    while(top != -1) \n    { \n        printf(\"%c\",pop()); \n    } \n} \n  \nOUTPUT: \nEnter the expression :: a+b*c \nabc*+ \n \nEnter the expression :: (a+b)*c+(d-a) \nab+c*da-+",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 57,
            "page_label": "58"
        }
    },
    {
        "content": "Evaluate POSTFIX Expression Using Stack \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \n13 \n14 \n15 \n16 \n17 \n18 \n19 \n20 \n21 \n22 \n23 \n24 \n#include<stdio.h> \nint stack[20]; \nint top = -1; \n void push(int x) \n{ \n        stack[++top] = x; \n} \n  \nint pop() \n{ \n        return stack[top--]; \n} \n  \nint main() \n{ \n        char exp[20]; \n        char *e; \n        int n1,n2,n3,num; \n        printf(\"Enter the expression :: \"); \n        scanf(\"%s\",exp); \n        e = exp; \n        while(*e != '\\0') \n        { \n                if(isdigit(*e))",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 58,
            "page_label": "59"
        }
    },
    {
        "content": "25 \n26 \n27 \n28 \n29 \n30 \n31 \n32 \n33 \n34 \n35 \n36 \n37 \n38 \n39 \n40 \n41 \n42 \n43 \n44 \n45 \n46 \n47 \n48 \n49 \n                { \n                        num = *e - 48; \n                        push(num); \n                } \n                else \n                { \n                        n1 = pop(); \n                        n2 = pop(); \n                        switch(*e) \n                        { \n                                case '+': \n                                { \n                                        n3 = n1 + n2; \n                    break; \n                                }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 59,
            "page_label": "60"
        }
    },
    {
        "content": "break; \n                                } \n                                case '-': \n                                { \n                                        n3 = n2 - n1; \n                                        break; \n                                } \n                                case '*': \n                                { \n                                        n3 = n1 * n2; \n                                        break; \n                                }",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 59,
            "page_label": "60"
        }
    },
    {
        "content": "50 \n51 \n52 \n53 \n54 \n55 \n56 \n57 \n58 \n59 \n60 \n61 \n62 \n63 \n64 \n                                case '/': \n                                { \n                                        n3 = n2 / n1; \n                                        break; \n                                } \n                        } \n                        push(n3); \n                } \n                e++; \n        } \n        printf(\"\\nThe result of expression %s  =  %d\\n\\n\",exp,pop()); \n        return 0; \n  \n} \nOutput: \nEnter the expression :: 245+* \n \nThe result of expression 245+*  =  18",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 60,
            "page_label": "61"
        }
    },
    {
        "content": "Lecture-13 \nBinary Tree \nA binary tree  consists of a finite set of nodes that is either empty, or consists of one \nspecially designated node called the  root of the binary tree, and the elements of two \ndisjoint binary trees called the left subtree and right subtree of the root. \nNote that the definition above is recursive: we have defined a binary tree in terms of \nbinary trees. This is appropriate since recursion is an innate characteristic of tree \nstructures. \nDiagram 1: A binary tree \n \nBinary Tree Terminology",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 61,
            "page_label": "62"
        }
    },
    {
        "content": "structures. \nDiagram 1: A binary tree \n \nBinary Tree Terminology \nTree terminology i s generally derived from the terminology of family trees (specifically, \nthe type of family tree called a lineal chart). \n Each root is said to be the parent of the roots of its subtrees. \n Two nodes with the same parent are said to be  siblings; they are the  children of \ntheir parent. \n The root node has no parent. \n A great deal of tree processing takes advantage of the relationship between a \nparent and its children, and we commonly say a  directed edge  (or simply",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 61,
            "page_label": "62"
        }
    },
    {
        "content": "parent and its children, and we commonly say a  directed edge  (or simply \nan edge) extends from a parent to its children. Thus edges connect a root with \nthe roots of each subtree. An undirected edge extends in both directions between \na parent and a child.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 61,
            "page_label": "62"
        }
    },
    {
        "content": " Grandparent and grandchild relations can be defined in a similar manner; we \ncould also extend this terminology further if we wi shed (designating nodes as \ncousins, as an uncle or aunt, etc.). \nOther Tree Terms \n The number of subtrees of a node is called the  degree of the node. In a binary \ntree, all nodes have degree 0, 1, or 2. \n A node of degree zero is called a terminal node or leaf node. \n A non-leaf node is often called a branch node. \n The degree of a tree  is the maximum degree of a node in the tree. A binary tree \nis degree 2.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 62,
            "page_label": "63"
        }
    },
    {
        "content": " The degree of a tree  is the maximum degree of a node in the tree. A binary tree \nis degree 2. \n A directed path  from node  n1 to nk is defined as a sequence of nodes  n1, n2, \n..., nk such that  ni is the paren t of  ni+1 for 1 <=  i < k. An  undirected path  is a \nsimilar sequence of undirected edges. The length of this path is the number of \nedges on the path, namely  k – 1 (i.e., the number of nodes – 1). There is a path \nof length zero from every node to itself. Noti ce that in a binary tree there is \nexactly one path from the root to each node.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 62,
            "page_label": "63"
        }
    },
    {
        "content": "exactly one path from the root to each node. \n The level or depth of a node with respect to a tree is defined recursively: the level \nof the root is zero; and the level of any other node is one higher than that of its \nparent. Or to put it another way, the level or depth of a node ni is the length of the \nunique path from the root to ni. \n The height of ni is the length of the longest path from  ni to a leaf. Thus all leaves \nin the tree are at height 0. \n The height of a tree is equal to the height of the root. The  depth of a tree is equal",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 62,
            "page_label": "63"
        }
    },
    {
        "content": " The height of a tree is equal to the height of the root. The  depth of a tree is equal \nto the level or depth of the deepest leaf; this is always equal to the height of the \ntree. \n If there is a directed path from  n1 to n2, then  n1 is an ancestor of  n2 and n2 is a \ndescendant of n1.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 62,
            "page_label": "63"
        }
    },
    {
        "content": "Lecture-14 \nSpecial Forms of Binary Trees \nThere are a few special forms of binary tree worth mentioning. \nIf every non-leaf node in a binary tree has nonempty left and right subtrees, the tree is \ntermed a strictly binary tree. Or, to put it another way, all of t he nodes in a strictly binary \ntree are of degree zero or two, never degree one. A strictly binary tree with  N leaves \nalways contains 2N – 1 nodes. \nSome texts call this a \"full\" binary tree. \nA complete binary tree  of depth  d is the strictly binary tree all of whose leaves are at \nlevel d.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 63,
            "page_label": "64"
        }
    },
    {
        "content": "level d. \nThe total number of nodes in a complete binary tree of depth  d equals 2d+1 – 1. Since all \nleaves in such a tree are at level  d, the tree contains 2 d leaves and, therefore, 2 d - 1 \ninternal nodes. \nDiagram 2: A complete binary tree \n \nA binary tree of depth d is an almost complete binary tree if: \n Each leaf in the tree is either at level d or at level d – 1. \n For any node  nd in the tree with a right descendant at level  d, all the left \ndescendants of nd that are leaves are also at level d. \nDiagram 3: An almost complete binary tree",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 63,
            "page_label": "64"
        }
    },
    {
        "content": "An almost complete strictly binary tree with  N leaves has 2 N – 1 nodes (as does any \nother strictly binary tree). An almost complete binary tree with  N leaves that is not \nstrictly binary has 2 N nodes. Ther e are two distinct almost complete binary trees \nwith N leaves, one of which is strictly binary and one of which is not. \nThere is only a single almost complete binary tree with  N nodes. This tree is strictly \nbinary if and only if N is odd. \nRepresenting Binary Trees in Memory \nArray Representation",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 64,
            "page_label": "65"
        }
    },
    {
        "content": "binary if and only if N is odd. \nRepresenting Binary Trees in Memory \nArray Representation \nFor a complete or almost complete binary tree, storing the binary tree as an array may \nbe a good choice. \nOne way to do this is to store the root of the tree in the first element of the array. Then, \nfor each node in t he tree that is stored at subscript  k, the node's left child can be stored \nat subscript 2 k+1 and the right child can be stored at subscript 2 k+2. For example, the \nalmost complete binary tree shown in Diagram 2 can be stored in an array like so:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 64,
            "page_label": "65"
        }
    },
    {
        "content": "almost complete binary tree shown in Diagram 2 can be stored in an array like so: \n \nHowever, if this scheme is used to store a binary tree that is not complete or almost \ncomplete, we can end up with a great deal of wasted space in the array.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 64,
            "page_label": "65"
        }
    },
    {
        "content": "For example, the following binary tree \n \nwould be stored using this techinque like so: \n \nLinked Representation \nIf a binary tree is not complete or almost complete, a better choice for storing it is to use \na linked representation similar to the linked list structures covered earlier in the \nsemester:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 65,
            "page_label": "66"
        }
    },
    {
        "content": "Each tree node has two pointers (usually named  left and right). The tree class has a \npointer to the root node of the tree (labeled root in the diagram above). \nAny pointer in the tree structure that does not point to a node will normally contain the \nvalue NULL. A linked tree with N nodes will always contain N + 1 null links.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 66,
            "page_label": "67"
        }
    },
    {
        "content": "Lecture-15 \nTree Traversal: \nTraversal is a process to visit all the nodes of a tree and may print their values too. \nBecause, all nodes are connected via edges (links) we always start from the root \n(head) node. That is, we cannot randomly access a node in a tree. There are three \nways which we use to traverse a tree − \n In-order Traversal \n Pre-order Traversal \n Post-order Traversal \nGenerally, we traverse a tree to search or locate a given item or key in the tree or to \nprint all the values it contains. \nIn-order Traversal",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 67,
            "page_label": "68"
        }
    },
    {
        "content": "print all the values it contains. \nIn-order Traversal \nIn this traversal method, the left subtree is visited first, then the root and later the right \nsub-tree. We should always remember that every node may represent a subtree itself. \nIf a binary tree is traversed  in-order, the output will produ ce sorted key values in an \nascending order. \n \nWe start from  A, and following in -order traversal, we move to its left subtree  B. B is \nalso traversed in-order. The process goes on until all the nodes are visited. The output \nof inorder traversal of this tree will be − \nD → B → E → A → F → C → G",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 67,
            "page_label": "68"
        }
    },
    {
        "content": "Algorithm \nUntil all nodes are traversed − \nStep 1 − Recursively traverse left subtree. \nStep 2 − Visit root node. \nStep 3 − Recursively traverse right subtree. \nPre-order Traversal \nIn this traversal method, the root node is visited first, then the left subtree and finally \nthe right subtree. \n \nWe start from A, and following pre -order traversal, we first visit  A itself and then move \nto its left subtree  B. B is also traversed pre -order. The process goes on until all the \nnodes are visited. The output of pre-order traversal of this tree will be − \nA → B → D → E → C → F → G \nAlgorithm",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 68,
            "page_label": "69"
        }
    },
    {
        "content": "A → B → D → E → C → F → G \nAlgorithm \nUntil all nodes are traversed − \nStep 1 − Visit root node. \nStep 2 − Recursively traverse left subtree. \nStep 3 − Recursively traverse right subtree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 68,
            "page_label": "69"
        }
    },
    {
        "content": "Post-order Traversal \nIn this traversal method, the root node is visited last, hence the name. First we traverse \nthe left subtree, then the right subtree and finally the root node. \n \nWe start from A, and following Post-order traversal, we first visit the left su btree B. B is \nalso traversed post -order. The process goes on until all the nodes are visited. Th e \noutput of post-order traversal of this tree will be − \nD → E → B → F → G → C → A \nAlgorithm \nUntil all nodes are traversed − \nStep 1 − Recursively traverse left subtree. \nStep 2 − Recursively traverse right subtree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 69,
            "page_label": "70"
        }
    },
    {
        "content": "Step 1 − Recursively traverse left subtree. \nStep 2 − Recursively traverse right subtree. \nStep 3 − Visit root node.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 69,
            "page_label": "70"
        }
    },
    {
        "content": "Lecture-16 \nAVL Trees \nAn AVL tree  is another balanced binary search tree. Named after their \ninventors, Adelson-Velskii and Landis, they were the first dynamically balanced trees to \nbe proposed. Like red -black trees, they are not perfectly balanced, but pairs of sub -\ntrees differ in height by at most 1, maintaining an  O(logn) search time. Addition and \ndeletion operations also take O(logn) time. \nDefinition of an AVL tree \nAn AVL tree is a binary search tree which has the following \nproperties: \n1. The sub-trees of every node differ in height by at most one.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 70,
            "page_label": "71"
        }
    },
    {
        "content": "properties: \n1. The sub-trees of every node differ in height by at most one. \n2. Every sub-tree is an AVL tree. \n \n  \nBalance requirement \nfor an AVL tree: the left \nand right sub -trees \ndiffer by at most 1 in \nheight. \nYou need to be careful with this definition: it permits some apparently unbalanced trees! \nFor example, here are some trees: \nTree AVL tree? \n \nYes \nExamination shows \nthat each left sub -tree \nhas a height 1 greater \nthan each right sub -\ntree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 70,
            "page_label": "71"
        }
    },
    {
        "content": "No \nSub-tree with root 8 has \nheight 4 and sub -tree \nwith root 18 has height \n2 \nInsertion \nAs with the red -black t ree, insertion is somewhat complex and involves a number of \ncases. Implementations of AVL tree insertion may be found in many textbooks: they rely \non adding an extra attribute, the balance factor  to each node. This factor indicates \nwhether the tree is  left-heavy (the height of the left sub -tree is 1 greater than the right \nsub-tree), balanced (both sub-trees are the same height) or right-heavy(the height of the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 71,
            "page_label": "72"
        }
    },
    {
        "content": "sub-tree), balanced (both sub-trees are the same height) or right-heavy(the height of the \nright sub-tree is 1 greater than the left sub -tree). If the balance would be destroyed by \nan insertion, a rotation is performed to correct the balance. \n \nA new item has been \nadded to the left subtree \nof node 1, causing its \nheight to become 2 \ngreater than 2's right sub -\ntree (shown in green). A \nright-rotation is performed \nto correct the imbalance.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 71,
            "page_label": "72"
        }
    },
    {
        "content": "Lecture-17 \nB+-tree \nIn B+-tree, each node stores up to  d references to children and up to  d − 1 keys. Each \nreference is considered “between” two of the node's keys; it references the root of a \nsubtree for which all values are between these two keys. \nHere is a fairly small tree using 4 as our value for d. \n \nA B+-tree requires that each leaf be the  same distance from the root, as in this picture, \nwhere searching for any of the 11 values (all listed on the bottom level) will involve \nloading three nodes from the disk (the root block, a second-level block, and a leaf).",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 72,
            "page_label": "73"
        }
    },
    {
        "content": "loading three nodes from the disk (the root block, a second-level block, and a leaf). \nIn practice, d will be larger — as large, in fact, as it takes to fill a disk block. Suppose a \nblock is 4KB, our keys are 4 -byte integers, and each reference is a 6 -byte file offset. \nThen we'd choose  d to be the largest value so that 4  (d − 1) + 6 d ≤ 4096; solving this \ninequality for d, we end up with  d ≤ 410, so we'd use 410 for  d. As you can see,  d can \nbe large. \nA B+-tree maintains the following invariants: \n Every node has one more references than it has keys.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 72,
            "page_label": "73"
        }
    },
    {
        "content": " Every node has one more references than it has keys. \n All leaves are at the same distance from the root. \n For every non -leaf node N with k being the number of keys in  N: all keys in the \nfirst child's subtree are less than  N's first key; and all keys in the  ith child's \nsubtree (2 ≤ i ≤ k) are between the (i − 1)th key of n and the ith key of n. \n The root has at least two children. \n Every non-leaf, non-root node has at least floor(d / 2) children.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 72,
            "page_label": "73"
        }
    },
    {
        "content": " Each leaf contains at least floor(d / 2) keys. \n Every key from the table appears in a leaf, in left-to-right sorted order. \nIn our examples, we'll c ontinue to use 4 for  d. Looking at our invariants, this requires \nthat each leaf have at least two keys, and each internal node to have at least two \nchildren (and thus at least one key). \n2. Insertion algorithm \nDescend to the leaf where the key fits. \n1. If the node has an empty space, insert the key/reference pair into the node. \n2. If the node is already full, split it into two nodes, distributing the keys evenly",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 73,
            "page_label": "74"
        }
    },
    {
        "content": "2. If the node is already full, split it into two nodes, distributing the keys evenly \nbetween the two nodes. If the node is a leaf, take a copy of the minimum value in \nthe second of these t wo nodes and repeat this insertion algorithm to insert it into \nthe parent node. If the node is a non -leaf, exclude the middle value during the \nsplit and repeat this insertion algorithm to insert this excluded value into the \nparent node. \nInitial: \n \nInsert 20: \n \nInsert 13:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 73,
            "page_label": "74"
        }
    },
    {
        "content": "Insert 15: \n \nInsert 10: \n \nInsert 11: \n \nInsert 12: \n \n3. Deletion algorithm \nDescend to the leaf where the key exists. \n1. Remove the required key and associated reference from the node. \n2. If the node still has enough keys and references to satisfy the invariants, stop.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 74,
            "page_label": "75"
        }
    },
    {
        "content": "3. If the node has too few keys to satisfy the invariants, but its next oldest or next \nyoungest sibling at the same level has more than necessary, distribute the keys \nbetween this node and the neighbor. Repair the keys in the le vel above to \nrepresent that these nodes now have a different “split point” between them; this \ninvolves simply changing a key in the levels above, without deletion or insertion. \n4. If the node has too few keys to satisfy the invariant, and the next oldest or n ext \nyoungest sibling is at the minimum for the invariant, then merge the node with its",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 75,
            "page_label": "76"
        }
    },
    {
        "content": "youngest sibling is at the minimum for the invariant, then merge the node with its \nsibling; if the node is a non -leaf, we will need to incorporate the “split key” from \nthe parent into our merging. In either case, we will need to repeat the removal \nalgorithm on the parent node to remove the “split key” that previously separated \nthese merged nodes — unless the parent is the root and we are removing the \nfinal key from the root, in which case the merged node becomes the new root \n(and the tree has become one level shorter than before). \nInitial: \n \nDelete 13:",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 75,
            "page_label": "76"
        }
    },
    {
        "content": "Delete 15: \n \nDelete 1: \n \nExpression Trees: \nTrees are used in many other ways in the computer science. Compilers and database \nare two major examples in this regard. In case of compilers, when the lang uages are \ntranslated into machine language, tree -like structures are used. We have also seen an \nexample of expression tree comprising the mathematical expression. Let’s have more \ndiscussion on the expression trees. We will see what are the benefits of expr ession \ntrees and how can we build an expression tree. Following is the figure of an expression \ntree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 76,
            "page_label": "77"
        }
    },
    {
        "content": "In the above tree, the expres sion on the left side is a + b * c while on the right side, we \nhave d * e + f * g. If you look at the figure, it becomes evident that the inner nodes \ncontain operators while leaf nodes have operands. We know that there are two types of \nnodes in the tree i.e. inner nodes and leaf nodes. The leaf nodes are such nodes which \nhave left and right subtrees as null. You will find these at the bottom level of the tree. \nThe leaf nodes are connected with the inner nodes. So in trees, we have some inner \nnodes and some leaf nodes.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 77,
            "page_label": "78"
        }
    },
    {
        "content": "nodes and some leaf nodes. \nIn the above diagram, all the inner nodes (the nodes which have either left or right child \nor both) have operators. In this case, we have + or * as operators. Whereas leaf nodes \ncontain operands only i.e. a, b, c, d, e, f, g. This tree is binar y as the operators are \nbinary. We have discussed the evaluation of postfix and infix expressions and have \nseen that the binary operators need two operands. In the infix expressions, one operand \nis on the left side of the operator and the other is on the ri ght side. Suppose, if we have",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 77,
            "page_label": "78"
        }
    },
    {
        "content": "is on the left side of the operator and the other is on the ri ght side. Suppose, if we have \n+ operator, it will be written as 2 + 4. However, in case of multiplication, we will write as \n5*6. We may have unary operators like negation ( -) or in Boolean expression we have \nNOT. In this example, there are all the binary o perators. Therefore, this tree is a binary \ntree. This is not the Binary Search Tree. In BST, the values on the left side of the nodes \nare smaller and the values on the right side are greater than the node. Therefore, this is",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 77,
            "page_label": "78"
        }
    },
    {
        "content": "are smaller and the values on the right side are greater than the node. Therefore, this is \nnot a BST. Here we have an expression tree with no sorting process involved. \nThis is not necessary that expression tree is always binary tree. Suppose we have a \nunary operator like negation. In this case, we have a node which has (-) in it and there is \nonly one leaf node under it. It means just negate that operand. \nLet’s talk about the traversal of the expression tree. The inorder traversal may be \nexecuted here.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 77,
            "page_label": "78"
        }
    },
    {
        "content": "Lecture-18 \nBinary Search Tree (BST) \nA Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned \nproperties − \n The left sub-tree of a node has a key less than or equal to its parent node's key. \n The right sub-tree of a node has a key greater than to its parent node's key. \nThus, BST divides all its sub -trees into two segments; the left sub -tree and the right \nsub-tree and can be defined as − \nleft_subtree (keys)  ≤  node (key)  ≤  right_subtree (keys) \nRepresentation \nBST is a collection o f nodes arranged in a way where they maintain BST properties.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 78,
            "page_label": "79"
        }
    },
    {
        "content": "BST is a collection o f nodes arranged in a way where they maintain BST properties. \nEach node has a key and an associated value. While searching, the desired key is \ncompared to the keys in BST and if found, the associated value is retrieved. \nFollowing is a pictorial representation of BST − \n \nWe observe that the root node key (27) has all less -valued keys on the left sub -tree \nand the higher valued keys on the right sub-tree. \nBasic Operations \nFollowing are the basic operations of a tree − \n Search − Searches an element in a tree. \n Insert − Inserts an element in a tree.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 78,
            "page_label": "79"
        }
    },
    {
        "content": " Search − Searches an element in a tree. \n Insert − Inserts an element in a tree. \n Pre-order Traversal − Traverses a tree in a pre-order manner. \n In-order Traversal − Traverses a tree in an in-order manner. \n Post-order Traversal − Traverses a tree in a post-order manner. \nNode",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 78,
            "page_label": "79"
        }
    },
    {
        "content": "Define a node having some data, references to its left and right child nodes. \nstruct node { \n   int data;    \n   struct node *leftChild; \n   struct node *rightChild; \n}; \nSearch Operation \nWhenever an element is to be searched, start searching from the root node. Then if the \ndata is less than the ke y value, search for the element in the left subtree. Otherwise, \nsearch for the element in the right subtree. Follow the same algorithm for each node. \nAlgorithm \nstruct node* search(int data){ \n   struct node *current = root; \n   printf(\"Visiting elements: \");",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 79,
            "page_label": "80"
        }
    },
    {
        "content": "struct node *current = root; \n   printf(\"Visiting elements: \"); \n  \n   while(current->data != data){ \n  \n      if(current != NULL) { \n         printf(\"%d \",current->data); \n    \n         //go to left tree \n         if(current->data > data){ \n            current = current->leftChild; \n         }  //else go to right tree \n         else {                 \n            current = current->rightChild; \n         } \n    \n         //not found",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 79,
            "page_label": "80"
        }
    },
    {
        "content": "if(current == NULL){ \n            return NULL; \n         } \n      }    \n   } \n    \n   return current; \n} \nInsert Operation \nWhenever an element is to be inserted, first locate its proper location. Start searching \nfrom the root node, then if the data is less than the key value, search for the empty \nlocation in the left subtree and insert the data. Otherwise, search for the empty location \nin the right subtree and insert the data. \nAlgorithm \nvoid insert(int data) { \n   struct node *tempNode = (struct node*) malloc(sizeof(struct node)); \n   struct node *current; \n   struct node *parent;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 80,
            "page_label": "81"
        }
    },
    {
        "content": "struct node *current; \n   struct node *parent; \n \n   tempNode->data = data; \n   tempNode->leftChild = NULL; \n   tempNode->rightChild = NULL; \n \n   //if tree is empty \n   if(root == NULL) { \n      root = tempNode; \n   } else { \n      current = root; \n      parent = NULL;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 80,
            "page_label": "81"
        }
    },
    {
        "content": "while(1) {                 \n         parent = current; \n    \n         //go to left of the tree \n         if(data < parent->data) { \n            current = current->leftChild;                 \n            //insert to the left \n     \n            if(current == NULL) { \n               parent->leftChild = tempNode; \n               return; \n            } \n         }  //go to right of the tree \n         else { \n            current = current->rightChild; \n             \n            //insert to the right \n            if(current == NULL) { \n               parent->rightChild = tempNode;",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 81,
            "page_label": "82"
        }
    },
    {
        "content": "if(current == NULL) { \n               parent->rightChild = tempNode; \n               return; \n            } \n         } \n      }             \n   } \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 81,
            "page_label": "82"
        }
    },
    {
        "content": "Module-3: \nLecture-19 \nGraphs Terminology \nA graph consists of: \n A set, V, of vertices (nodes) \n A collection, E, of pairs of vertices from V called edges (arcs) \nEdges, also called arcs, are represented by (u, v) and are either: \nDirected if the pairs are ordered (u, v) \nu the origin \nv the destination \nUndirected if the pairs are unordered \nA graph is a pictorial representation of a set of objects where some pairs of objects are \nconnected by links. The interconnected objects are represented b y points termed \nas vertices, and the links that connect the vertices are called edges.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 82,
            "page_label": "83"
        }
    },
    {
        "content": "as vertices, and the links that connect the vertices are called edges. \nFormally, a graph is a pair of sets  (V, E), where V is the set of vertices and  Eis the set \nof edges, connecting the pairs of vertices. Take a look at the following graph − \n \nIn the above graph, \nV = {a, b, c, d, e} \nE = {ab, ac, bd, cd, de} \nThen a graph can be: \nDirected graph (di-graph) if all the edges are directed  \nUndirected graph (graph) if all the edges are undirected  \nMixed graph if edges are both directed or undirected \nIllustrate terms on graphs \nEnd-vertices of an edge are the endpoints of the edge.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 82,
            "page_label": "83"
        }
    },
    {
        "content": "Illustrate terms on graphs \nEnd-vertices of an edge are the endpoints of the edge. \nTwo vertices are adjacent if they are endpoints of the same edge. \nAn edge is incident on a vertex if the vertex is an endpoint of the edge. \nOutgoing edges  of a vertex are directed edges that the vertex is the origin.   \nIncoming edges of a vertex are directed edges that the vertex is the destination. \nDegree of a vertex, v, denoted deg(v) is the number of incident edges.  \nOut-degree, outdeg(v), is the number of outgoing edges.  \nIn-degree, indeg(v), is the number of incoming edges.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 82,
            "page_label": "83"
        }
    },
    {
        "content": "In-degree, indeg(v), is the number of incoming edges. \nParallel edges or multiple edges are edges of the same type and end -vertices  \nSelf-loop is an edge with the end vertices the same vertex",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 82,
            "page_label": "83"
        }
    },
    {
        "content": "Simple graphs have no parallel edges or self-loops \nProperties \nIf graph, G, has m edges then  Σv∈G deg(v) = 2m \nIf a di-graph, G, has m edges then   \nΣv∈G indeg(v) = m = Σv∈G outdeg(v)  \nIf a simple graph, G, has m edges and n vertices: \nIf G is also directed then m ≤ n(n-1)  \nIf G is also undirected  then m ≤ n(n-1)/2 \nSo a simple graph with n vertices has O(n2) edges at most \nMore Terminology \nPath is a sequence of alternating vetches and edges such that each successive vertex \nis connected by the edge.   Frequently only the vertices are listed especially if there are \nno parallel edges.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 83,
            "page_label": "84"
        }
    },
    {
        "content": "no parallel edges.  \nCycle is a path that starts and end at the same vertex.  \nSimple path is a path with distinct vertices.  \nDirected path is a path of only directed edges  \nDirected cycle is a cycle of only directed edges. \nSub-graph is a subset of vertices and edges. \nSpanning sub-graph contains all the vertices. \nConnected graph  has all pairs of vertices connected by at least one path.   \nConnected component is the maximal connected sub -graph of a unconnected graph.   \nForest is a graph without cycles.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 83,
            "page_label": "84"
        }
    },
    {
        "content": "Forest is a graph without cycles.  \nTree is a connected forest (previous type of trees are called rooted trees, these are free \ntrees)  \nSpanning tree is a spanning subgraph that is also a tree. \nMore Properties \nIf G is an undirected graph with n vertices and m edges: \n If G is connected then m ≥ n - 1 \n If G is a tree then m = n - 1 \n If G is a forest then m ≤ n – 1 \nGraph Traversal: \n1. Depth First Search \n2. Breadth First Search",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 83,
            "page_label": "84"
        }
    },
    {
        "content": "Lecture-20 \nDepth First Search: \nDepth First Search (DFS) algorithm traverses a graph in a depthward motion and uses \na stack to r emember to get the next vertex to start a search, when a dead end occurs \nin any iteration. \n \nAs in the example given above, DFS algorithm traverses from S to A to D to G to E to \nB first, then to F and lastly to C. It employs the following rules. \n Rule 1 − Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it \nin a stack. \n Rule 2 − If no adjacent vertex is found, pop up a vertex from the stack. (It will",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 84,
            "page_label": "85"
        }
    },
    {
        "content": "in a stack. \n Rule 2 − If no adjacent vertex is found, pop up a vertex from the stack. (It will \npop up all the vertices from the stack, which do not have adjacent vertices.) \n Rule 3 − Repeat Rule 1 and Rule 2 until the stack is empty. \nStep Traversal Description \n1 \n \nInitialize the stack.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 84,
            "page_label": "85"
        }
    },
    {
        "content": "2 \n \nMark S as visited and put it \nonto the stack. Explore any \nunvisited adjacent node \nfrom S. We have three nodes \nand we can pick any of them. \nFor thi s example, we shall \ntake the node in an \nalphabetical order. \n3 \n \nMark A as visited and put it \nonto the stack. Explore any \nunvisited adjacent node from \nA. Both  Sand D are adjacent \nto A but we are concerned for \nunvisited nodes only. \n4 \n \nVisit D and mark it as visited \nand put onto the stack. Here, \nwe have  B and C nodes, \nwhich are adjacent to  D and \nboth are unvisited. However, \nwe shall again choose in an \nalphabetical order.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 85,
            "page_label": "86"
        }
    },
    {
        "content": "both are unvisited. However, \nwe shall again choose in an \nalphabetical order. \n5 \n \nWe choose  B, mark it as \nvisited and put onto the stack. \nHere Bdoes not have any \nunvisited adjacent node. So, \nwe pop Bfrom the stack.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 85,
            "page_label": "86"
        }
    },
    {
        "content": "6 \n \nWe check the stack top for \nreturn to the previous node \nand check if it has any \nunvisited nodes. Here, we \nfind D to be on the top of the \nstack. \n7 \n \nOnly unvisited adjacent node \nis from  D is C now. So we \nvisit C, mark it as visited and \nput it onto the stack. \nAs C does not have any unvisited adjacent node so we keep popping the stack until we \nfind a node that has an unvisited adjacent node. In this case, there's none and we keep \npopping until the stack is empty.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 86,
            "page_label": "87"
        }
    },
    {
        "content": "Lecture-21 \nBreadth First Search \nBreadth First Search (BFS) algorithm traverses a graph in a breadthward motion and \nuses a queue to remember to get the next vertex to start a search, when a dead end \noccurs in any iteration. \n \nAs in the example given above, BFS algorithm traverses from A to B to E to F first then \nto C and G lastly to D. It employs the following rules. \n Rule 1 − Visit the adjacent unvisited vertex. Mark it as visited. Display it. Insert it \nin a queue. \n Rule 2 − If no adjacent vertex is found, remove the first vertex from the queue.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 87,
            "page_label": "88"
        }
    },
    {
        "content": "in a queue. \n Rule 2 − If no adjacent vertex is found, remove the first vertex from the queue. \n Rule 3 − Repeat Rule 1 and Rule 2 until the queue is empty. \nStep Traversal Description \n1 \n \nInitialize the queue.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 87,
            "page_label": "88"
        }
    },
    {
        "content": "2 \n \nWe start from \nvisiting S(starting node), and \nmark it as visited. \n3 \n \nWe then see an unv isited \nadjacent node from  S. In this \nexample, we have three nodes \nbut alphabetically we \nchoose A, mark it as visited \nand enqueue it. \n4 \n \nNext, the unvisited adjacent \nnode from  S is B. We mark it \nas visited and enqueue it. \n5 \n \nNext, the unvisited adjacent  \nnode from  S is C. We mark it \nas visited and enqueue it.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 88,
            "page_label": "89"
        }
    },
    {
        "content": "6 \n \nNow, S is left with no unvisited \nadjacent nodes. So, we \ndequeue and find A. \n7 \n \nFrom A we have  D as \nunvisited adjacent node. We \nmark it as visited and enqueue \nit. \nAt this stage, we are left wi th no unmarked (unvisited) nodes. But as per the algorithm \nwe keep on dequeuing in order to get all unvisited nodes. When the queue gets \nemptied, the program is over.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 89,
            "page_label": "90"
        }
    },
    {
        "content": "Lecture-22 \nGraph representation \nYou can represent a graph in many ways. The two most com mon ways of representing \na graph is as follows: \nAdjacency matrix \nAn adjacency matrix is a  VxV binary matrix A. Element Ai,j is 1 if there is an edge from \nvertex i to vertex j else Ai,jis 0. \nNote: A binary matrix is a matrix in which the cells can have only  one of two possible \nvalues - either a 0 or 1. \nThe adjacency matrix can also be modified for the weighted graph in which instead of \nstoring 0 or 1 in Ai,j, the weight or cost of the edge will be stored.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 90,
            "page_label": "91"
        }
    },
    {
        "content": "storing 0 or 1 in Ai,j, the weight or cost of the edge will be stored. \nIn an undirected graph, if  Ai,j = 1, then  Aj,i = 1. I n a directed graph, if  Ai,j = 1, \nthen Aj,i may or may not be 1. \nAdjacency matrix provides  constant time access  (O(1) )  to determine if there is an \nedge between two nodes. Space complexity of the adjacency matrix is O(V2). \nThe adjacency matrix of the follow ing graph is:  \ni/j : 1 2 3 4 \n1 : 0 1 0 1 \n2 : 1 0 1 0 \n3 : 0 1 0 1 \n4 : 1 0 1 0 \n \nThe adjacency matrix of the following graph is: \ni/j: 1 2 3 4 \n1 : 0 1 0 0 \n2 : 0 0 0 1 \n3 : 1 0 0 1 \n4 : 0 1 0 0",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 90,
            "page_label": "91"
        }
    },
    {
        "content": "Adjacency list \nThe other way to represent a graph is by using an ad jacency list. An adjacency list is an \narray A of separate lists. Each element of the array  Ai is a list, which contains all the \nvertices that are adjacent to vertex i. \nFor a weighted graph, the weight or cost of the edge is stored along with the vertex in \nthe list using pairs. In an undirected graph, if vertex j is in list  Ai then vertex i will be in \nlist Aj. \nThe space complexity of adjacency list is  O(V + E)  because in an adjacency list",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 91,
            "page_label": "92"
        }
    },
    {
        "content": "list Aj. \nThe space complexity of adjacency list is  O(V + E)  because in an adjacency list \ninformation is stored only for those edges that actually exist in the graph. In a lot of \ncases, where a matrix is sparse using an adjacency matrix may not be very useful. This \nis because using an adjacency matrix will take up a lot of space where most of the \nelements will be 0, anyway. In such cases, using an adjacency list is better. \nNote: A sparse matrix is a matrix in which most of the elements are zero, whereas a \ndense matrix is a matrix in which most of the elements are non-zero.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 91,
            "page_label": "92"
        }
    },
    {
        "content": "dense matrix is a matrix in which most of the elements are non-zero. \n \nConsider the same undirected graph from an adjacency matrix. The adjacency list of the \ngraph is as follows: \nA1 → 2 → 4 \n \nA2 → 1 → 3 \n \nA3 → 2 → 4",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 91,
            "page_label": "92"
        }
    },
    {
        "content": "A4 → 1 → 3 \n \n \nConsider the same directed graph from an adjacency matrix. The adjacency list of the \ngraph is as follows: \nA1 → 2 \n \nA2 → 4 \n \nA3 → 1 → 4 \n \nA4 → 2",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 92,
            "page_label": "93"
        }
    },
    {
        "content": "Lecture-23 \nTopological Sorting: \nTopological sorting for Directed  Acyclic Graph (DAG) is a linear ordering of vertices \nsuch that for every directed edge uv, vertex u comes before v in the \nordering. Topological Sorting for a graph is not possible if the graph is not a DAG. \nFor example, a topological sorting of the follow ing graph is “5 4 2 3 1 0”. There can be \nmore than one topological sorting for a graph. For example, another topological sorting \nof the following graph is “4 5 2 3 1 0”. The first vertex in topological sorting is always a",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 93,
            "page_label": "94"
        }
    },
    {
        "content": "of the following graph is “4 5 2 3 1 0”. The first vertex in topological sorting is always a \nvertex with in-degree as 0 (a vertex with no in-coming edges). \nAlgorithm to find Topological Sorting: \nIn DFS, we start from a vertex, we first print it and then recursively call DFS for its \nadjacent vertices. In topological sorting, we use a temporary stack. We don’t print the \nvertex immediately, we first recursively call topological sorting for all its adjacent \nvertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 93,
            "page_label": "94"
        }
    },
    {
        "content": "vertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is  \npushed to stack only when all of its adjacent vertices (and their adjacent vertices and so \non) are already in stack. \nTopological Sorting vs Depth First Traversal (DFS): \nIn DFS, we print a vertex and then recursively call DFS for its adjacent vertices. In \ntopological sorting, we need to print a vertex before its adjacent vertices. For example, \nin the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but  unlike DFS, the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 93,
            "page_label": "94"
        }
    },
    {
        "content": "in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but  unlike DFS, the \nvertex  ‘4’ should also be printed before vertex ‘0’. So Topological sorting is different \nfrom DFS. For example, a DFS of the shown graph is “5 2 3 1 0 4”, but it is not a \ntopological sorting\n  \nDynamic Programming  \nThe Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The \nproblem is to find shortest distances between every pair of vertices in a given edge \nweighted directed Graph. \nExample: \nInput: \n       graph[][] = { {0,   5,  INF, 10},",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 93,
            "page_label": "94"
        }
    },
    {
        "content": "weighted directed Graph. \nExample: \nInput: \n       graph[][] = { {0,   5,  INF, 10}, \n                    {INF,  0,  3,  INF}, \n                    {INF, INF, 0,   1}, \n                    {INF, INF, INF, 0} } \nwhich represents the following graph \n             10",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 93,
            "page_label": "94"
        }
    },
    {
        "content": "(0)------->(3) \n        |         /|\\ \n      5 |          | \n        |          | 1 \n       \\|/         | \n       (1)------->(2) \n            3        \nNote that the value of graph[i][j] is 0 if i is equal to j  \nAnd graph[i][j] is INF (infinite) if there is no edge from vertex i to j. \n \nOutput: \nShortest distance matrix \n      0      5      8      9 \n    INF      0      3      4 \n    INF    INF      0      1 \n    INF    INF    INF      0  \nFloyd Warshall Algorithm \n \nWe initialize the solution matrix same as the input graph matrix as a first step. Then we",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 94,
            "page_label": "95"
        }
    },
    {
        "content": "We initialize the solution matrix same as the input graph matrix as a first step. Then we \nupdate the solution matrix by considering all vertices as an intermediate vertex. The \nidea is to one by one pick all vertices and update all shortest paths which include the \npicked vertex as an intermediate vertex in the shortest path . When we pick vertex \nnumber k as an intermediate vertex, we already have considered vertices {0, 1, 2, .. k-1} \nas intermediate vertices. For every pair (i, j) of source and destination vertices \nrespectively, there are two possible cases.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 94,
            "page_label": "95"
        }
    },
    {
        "content": "respectively, there are two possible cases.  \n1) k is not an in termediate vertex in shortest path from i to j. We keep the value of \ndist[i][j] as it is. \n2) k is an intermediate vertex in shortest path from i to j. We update the value of dist[i][j] \nas dist[i][k] + dist[k][j]. \nThe following figure shows the above optima l substructure property in the all -pairs \nshortest path problem.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 94,
            "page_label": "95"
        }
    },
    {
        "content": "Lecture-24 \nBubble Sort \nWe take an unsorted array for our example. Bubble sort takes Ο(n 2) ti me so we're \nkeeping it short and precise. \n \nBubble sort starts with very first two elements, comparing them to check which one is \ngreater. \n \nIn this case, value 33 is greater than 14, so it is already in sorted locations. Next, we \ncompare 33 with 27. \n \nWe find that 27 is smaller than 33 and these two values must be swapped. \n \nThe new array should look like this − \n \nNext we compare 33 and 35. We find that both are in already sorted positions.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 95,
            "page_label": "96"
        }
    },
    {
        "content": "Next we compare 33 and 35. We find that both are in already sorted positions. \n \nThen we move to the next two values, 35 and 10. \n \nWe know then that 10 is smaller 35. Hence they are not sorted. \n \nWe swap these values.  We find that we have reached the end of the array. After one \niteration, the array should look like this − \n \nTo be precise, we are now showing how an array should look like after each iteration. \nAfter the second iteration, it should look like this −",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 95,
            "page_label": "96"
        }
    },
    {
        "content": "Notice that after each iteration, at least one value moves at the end. \n \nAnd when there's no swap required, bubble sorts learns that an array is completely \nsorted. \n \nNow we should look into some practical aspects of bubble sort. \nAlgorithm \nWe assume  list is an array of  n elements. We further assume that  swapfunction \nswaps the values of the given array elements. \nbegin BubbleSort(list) \n \n   for all elements of list \n      if list[i] > list[i+1] \n         swap(list[i], list[i+1]) \n      end if \n   end for \n    \n   return list \n    \nend BubbleSort \nPseudocode",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 96,
            "page_label": "97"
        }
    },
    {
        "content": "end if \n   end for \n    \n   return list \n    \nend BubbleSort \nPseudocode \nWe observe in algorithm that Bubble Sort compares each pair of array element unless \nthe whole array is completely sorted in an ascending order. This may cause a few \ncomplexity issues like what if the array needs no more s wapping as all the elements \nare already ascending. \nTo ease-out the issue, we use one flag variable  swapped which will help us see if any \nswap has happened or not. If no swap has occurred, i.e. the array requires no more \nprocessing to be sorted, it will come out of the loop.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 96,
            "page_label": "97"
        }
    },
    {
        "content": "processing to be sorted, it will come out of the loop. \nPseudocode of BubbleSort algorithm can be written as follows − \nprocedure bubbleSort( list : array of items ) \n \n   loop = list.count; \n    \n   for i = 0 to loop-1 do: \n      swapped = false",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 96,
            "page_label": "97"
        }
    },
    {
        "content": "for j = 0 to loop-1 do: \n       \n         /* compare the adjacent elements */    \n         if list[j] > list[j+1] then \n            /* swap them */ \n            swap( list[j], list[j+1] )    \n            swapped = true \n         end if \n          \n      end for \n       \n      /*if no number was swapped that means  \n      array is sorted now, break the loop.*/ \n       \n      if(not swapped) then \n         break \n      end if \n       \n   end for \n    \nend procedure return list",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 97,
            "page_label": "98"
        }
    },
    {
        "content": "Lecture-25 \nInsertion Sort  \nWe take an unsorted array for our example. \n \nInsertion sort compares the first two elements. \n \nIt finds that both 14 and 33 are already in ascending order. For now, 14 is in sorted \nsub-list. \n \nInsertion sort moves ahead and compares 33 with 27. \n \nAnd finds that 33 is not in the correct position. \n \nIt swaps 33 with 27. It also checks with all the elements of sorted sub -list. Here we see \nthat the sorted sub-list has only one element 14, and 27 is greater than 14. Hence, the \nsorted sub-list remains sorted after swapping.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 98,
            "page_label": "99"
        }
    },
    {
        "content": "sorted sub-list remains sorted after swapping. \n \nBy now we have 14 and 27 in the sorted sub-list. Next, it compares 33 with 10. \n \nThese values are not in a sorted order. \n \nSo we swap them. \n \nHowever, swapping makes 27 and 10 unsorted.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 98,
            "page_label": "99"
        }
    },
    {
        "content": "Hence, we swap them too. \n \nAgain we find 14 and 10 in an unsorted order. \n \nWe swap them again. By the end of third iteration, we have a sorted sub-list of 4 items. \n \nThis process goes on until all the unsorted values are covered in a sorted sub -list. Now \nwe shall see some programming aspects of insertion sort. \nAlgorithm \nNow we have a bigger picture of how this sorting techni que works, so we can derive \nsimple steps by which we can achieve insertion sort. \nStep 1 − If it is the first element, it is already sorted. return 1; \nStep 2 − Pick next element",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 99,
            "page_label": "100"
        }
    },
    {
        "content": "Step 1 − If it is the first element, it is already sorted. return 1; \nStep 2 − Pick next element \nStep 3 − Compare with all elements in the sorted sub-list \nStep 4 − Shift all the elements in the sorted sub-list that is greater than the  \n         value to be sorted \nStep 5 − Insert the value \nStep 6 − Repeat until list is sorted \nPseudocode \nprocedure insertionSort( A : array of items ) \n   int holePosition \n   int valueToInsert \n   for i = 1 to length(A) inclusive do: \n      valueToInsert = A[i] \n      holePosition = i",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 99,
            "page_label": "100"
        }
    },
    {
        "content": "for i = 1 to length(A) inclusive do: \n      valueToInsert = A[i] \n      holePosition = i \n   \n      while holePosition > 0 and A[holePosition-1] > valueToInsert do: \n         A[holePosition] = A[holePosition-1] \n         holePosition = holePosition -1 \n      end while \n      A[holePosition] = valueToInsert \n       \n   end for \n end procedure",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 99,
            "page_label": "100"
        }
    },
    {
        "content": "Lecture-26 \nSelection Sort \nConsider the following depicted array as an example. \n \nFor the first position in the sorted list, the whole list is scanned sequentially. The first \nposition where 14 is stored presently, we search the whole list and find that 10 is the \nlowest value. \n \nSo we replace 14 with 10. After one iteration 10, which happens to be the minimum \nvalue in the list, appears in the first position of the sorted list. \n \nFor the second position, where 33 is residing, we start scanning the rest of the list in a \nlinear manner.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 100,
            "page_label": "101"
        }
    },
    {
        "content": "linear manner. \n \nWe find that 14 is the second lowest value in the list and it should appear at the second \nplace. We swap these values. \n \nAfter two iterations, two least val ues are positioned at the beginning in a sorted \nmanner. \n \nThe same process is applied to the rest of the items in the array. \nFollowing is a pictorial depiction of the entire sorting process −",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 100,
            "page_label": "101"
        }
    },
    {
        "content": "Now, let us learn some programming aspects of selection sort. \nAlgorithm \nStep 1 − Set MIN to location 0 \nStep 2 − Search the minimum element in the list \nStep 3 − Swap with value at location MIN \nStep 4 − Increment MIN to point to next element \nStep 5 − Repeat until list is sorted",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 101,
            "page_label": "102"
        }
    },
    {
        "content": "Pseudocode \nprocedure selection sort  \n   list  : array of items \n   n     : size of list \n \n   for i = 1 to n - 1 \n   /* set current element as minimum*/ \n      min = i     \n   \n      /* check the element to be minimum */ \n \n      for j = i+1 to n  \n         if list[j] < list[min] then \n            min = j; \n         end if \n      end for \n \n      /* swap the minimum element with the current element*/ \n      if indexMin != i  then \n         swap list[min] and list[i] \n      end if \n   end for \n  \nend procedure",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 102,
            "page_label": "103"
        }
    },
    {
        "content": "Lecture-27 \nMerge Sort  \nTo understand merge sort, we take an unsorted array as the following − \n \nWe know that merge sort first divides the whole array iteratively into equal halves \nunless the atomic values are achieved. We see here that an array of 8 items is divided \ninto two arrays of size 4. \n \nThis does not chan ge the sequence of appearance of items in the original. Now we \ndivide these two arrays into halves. \n \nWe further divide these arrays and we achieve atomic value which can no more be \ndivided. \n \nNow, we combine them in exactly the same manner as they were br oken down. Please",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 103,
            "page_label": "104"
        }
    },
    {
        "content": "divided. \n \nNow, we combine them in exactly the same manner as they were br oken down. Please \nnote the color codes given to these lists. \nWe first compare the element for each list and then combine them into another list in a \nsorted manner. We see that 14 and 33 are in sorted positions. We compare 27 and 10 \nand in the target list of 2 values we put 10 first, followed by 27. We change the order of \n19 and 35 whereas 42 and 44 are placed sequentially. \n \nIn the next iteration of the combining phase, we compare lists of two data values, and",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 103,
            "page_label": "104"
        }
    },
    {
        "content": "In the next iteration of the combining phase, we compare lists of two data values, and \nmerge them into a list of found data values placing all in a sorted order. \n \nAfter the final merging, the list should look like this − \n \nNow we should learn some programming aspects of merge sorting. \nAlgorithm",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 103,
            "page_label": "104"
        }
    },
    {
        "content": "Merge sort keeps on dividing the list into equal halves until it can no more be divided. \nBy definition, if it is only one e lement in the list, it is sorted. Then, merge sort combines \nthe smaller sorted lists keeping the new list sorted too. \nStep 1 − if it is only one element in the list it is already sorted, return. \nStep 2 − divide the list recursively into two halves until it can no more be divided. \nStep 3 − merge the smaller lists into new list in sorted order. \nMerge sort works with recursion and we shall see our implementation in the same way. \nprocedure mergesort( var a as array )",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 104,
            "page_label": "105"
        }
    },
    {
        "content": "procedure mergesort( var a as array ) \n   if ( n == 1 ) return a \n   var l1 as array = a[0] ... a[n/2] \n   var l2 as array = a[n/2+1] ... a[n] \n   l1 = mergesort( l1 ) \n   l2 = mergesort( l2 ) \n   return merge( l1, l2 ) \nend procedure \nprocedure merge( var a as array, var b as array ) \n   var c as array \n   while ( a and b have elements ) \n      if ( a[0] > b[0] ) \n         add b[0] to the end of c \n         remove b[0] from b \n      else \n         add a[0] to the end of c \n         remove a[0] from a \n      end if \n   end while \n    \n   while ( a has elements )",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 104,
            "page_label": "105"
        }
    },
    {
        "content": "remove a[0] from a \n      end if \n   end while \n    \n   while ( a has elements ) \n      add a[0] to the end of c \n      remove a[0] from a \n   end while \n    \n   while ( b has elements ) \n      add b[0] to the end of c \n      remove b[0] from b \n   end while \n   return c \nend procedure",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 104,
            "page_label": "105"
        }
    },
    {
        "content": "Lecture-28 \nQuick sort \nQuick sort is a highly efficient sorting algorithm and is based on partitioning of  array of \ndata into smaller arrays. A large array is partitioned into two arrays one of which holds \nvalues smaller than the specified value, say pivot, based on which the partition is made \nand another array holds values greater than the pivot value. \nQuick sort partitions an array and then calls itself recursively twice to sort the two \nresulting subarrays. This algorithm is quite efficient for large -sized data sets as its",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 105,
            "page_label": "106"
        }
    },
    {
        "content": "resulting subarrays. This algorithm is quite efficient for large -sized data sets as its \naverage and worst case complexity are of Ο(n2), where n is the number of items. \nPartition in Quick Sort \nFollowing animated representation explains how to find the pivot value in an array. \n \nThe pivot value divides the list into two parts. And recursively, we find the pivot for \neach sub-lists until all lists contains only one element. \nQuick Sort Pivot Algorithm \nBased on our understanding of partitioning in quick sort, we will now try to write an \nalgorithm for it, which is as follows.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 105,
            "page_label": "106"
        }
    },
    {
        "content": "algorithm for it, which is as follows. \nStep 1 − Choose the highest index value has pivot \nStep 2 − Take two variables to point left and right of the list excluding pivot \nStep 3 − left points to the low index \nStep 4 − right points to the high \nStep 5 − while value at left is less than pivot move right \nStep 6 − while value at right is greater than pivot move left \nStep 7 − if both step 5 and step 6 does not match swap left and right \nStep 8 − if left ≥ right, the point where they met is new pivot \nQuick Sort Pivot Pseudocode \nThe pseudocode for the above algorithm can be derived as −",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 105,
            "page_label": "106"
        }
    },
    {
        "content": "Quick Sort Pivot Pseudocode \nThe pseudocode for the above algorithm can be derived as − \nfunction partitionFunc(left, right, pivot) \n   leftPointer = left \n   rightPointer = right - 1 \n \n   while True do \n      while A[++leftPointer] < pivot do",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 105,
            "page_label": "106"
        }
    },
    {
        "content": "//do-nothing             \n      end while \n   \n      while rightPointer > 0 && A[--rightPointer] > pivot do \n         //do-nothing          \n      end while \n   \n      if leftPointer >= rightPointer \n         break \n      else                 \n         swap leftPointer,rightPointer \n      end if \n   \n   end while  \n  \n   swap leftPointer,right \n   return leftPointer \n  \nend function \nQuick Sort Algorithm \nUsing pivot algorithm recursively, we end up with smaller possible partitions. Each \npartition is then processed for quick sort. We define recursive algorithm for quicksort as \nfollows −",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 106,
            "page_label": "107"
        }
    },
    {
        "content": "follows − \nStep 1 − Make the right-most index value pivot \nStep 2 − partition the array using pivot value \nStep 3 − quicksort left partition recursively \nStep 4 − quicksort right partition recursively \nQuick Sort Pseudocode \nTo get more into it, let see the pseudocode for quick sort algorithm − \nprocedure quickSort(left, right) \n \n   if right-left <= 0 \n      return \n   else      \n      pivot = A[right] \n      partition = partitionFunc(left, right, pivot) \n      quickSort(left,partition-1) \n      quickSort(partition+1,right)     \n   end if   \n   end procedure",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 106,
            "page_label": "107"
        }
    },
    {
        "content": "Lecture-29 \nHeap Sort \nHeap sort is a comparison based sorting technique based on Binary Heap data \nstructure. It is similar to selection sort where we first find the maximum element and \nplace the maximum element at the end. We repeat the same process for remaining \nelement. \nWhat is Binary Heap? \n \nLet us first define a Com plete Binary Tree. A complete binary tree is a binary tree in \nwhich every level, except possibly the last, is completely filled, and all nodes are as far \nleft as possible  \nA Binary Heap is a Complete Binary T ree where items are stored in a special order",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 107,
            "page_label": "108"
        }
    },
    {
        "content": "A Binary Heap is a Complete Binary T ree where items are stored in a special order \nsuch that value in a parent node is greater(or smaller) than the values in its two children \nnodes. The former is called as max heap and the latter is called min heap. The heap \ncan be represented by binary tree or array. \nWhy array based representation for Binary Heap? \n \nSince a Binary Heap is a Complete Binary Tree, it can be easily represented as array \nand array based representation is space efficient. If the parent node is stored at index I,",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 107,
            "page_label": "108"
        }
    },
    {
        "content": "and array based representation is space efficient. If the parent node is stored at index I, \nthe left child can b e calculated by 2 * I + 1 and right child by 2 * I + 2 (assuming the \nindexing starts at 0). \nHeap Sort Algorithm for sorting in increasing order: \n \n1. Build a max heap from the input data. \n2. At this point, the largest item is stored at the root of the heap.  Replace it with the last \nitem of the heap followed by reducing the size of heap by 1. Finally, heapify the root of \ntree. \n3. Repeat above steps while size of heap is greater than 1. \nHow to build the heap?",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 107,
            "page_label": "108"
        }
    },
    {
        "content": "tree. \n3. Repeat above steps while size of heap is greater than 1. \nHow to build the heap? \n \nHeapify procedure can be applied to a node only if  its children nodes are heapified. So \nthe heapification must be performed in the bottom up order. \nLets understand with the help of an example: \nInput data: 4, 10, 3, 5, 1 \n                 4(0) \n        /   \\ \n         10(1)   3(2) \n            /   \\ \n     5(3)    1(4) \n \nThe numbers in bracket represent the indices in the array  \nrepresentation of data.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 107,
            "page_label": "108"
        }
    },
    {
        "content": "Applying heapify procedure to index 1: \n         4(0) \n        /   \\ \n            10(1)    3(2) \n           /   \\ \n    5(3)    1(4) \n \nApplying heapify procedure to index 0: \n            10(0) \n        /  \\ \n         5(1)  3(2) \n            /   \\ \n         4(3)    1(4) \nThe heapify procedure calls itself recursively to build heap \n in top down manner. \nRadix Sort \nThe lower bound for Comparison based sorting algorithm  (Merge Sort, Heap Sort, \nQuick-Sort .. etc) is Ω(nLogn), i.e., they cannot do better than nLogn.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 108,
            "page_label": "109"
        }
    },
    {
        "content": "Quick-Sort .. etc) is Ω(nLogn), i.e., they cannot do better than nLogn. \nCounting sort is a linear time sorting algorithm that sort in O(n+k) time when elements \nare in range from 1 to k. \nWhat if the elements are in range from 1 to n2?  \n \nWe can’t use counting sort because counting sort will take O(n 2) which is worse than \ncomparison based sorting algorithms. Can we sort such an array in linear time?  \nRadix Sort is the answer. The idea of Radix Sort is to do digit by digit sort starting from \nleast significant di git to most significant digit. Radix sort uses counting sort as a",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 108,
            "page_label": "109"
        }
    },
    {
        "content": "least significant di git to most significant digit. Radix sort uses counting sort as a \nsubroutine to sort.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 108,
            "page_label": "109"
        }
    },
    {
        "content": "Lecture-30 \nRadix Sort  \n \n1) Do following for each digit i where i varies from least significant digit to the most \nsignificant digit. \n………….a) Sort input array using counti ng sort (or any stable sort) according to the i’th \ndigit. \nExample: \nOriginal, unsorted list: \n170, 45, 75, 90, 802, 24, 2, 66 \nSorting by least significant digit (1s place) gives: [*Notice that we keep 802 before 2, \nbecause 802 occurred before 2 in the origin al list, and similarly for pairs 170 & 90 and \n45 & 75.] \n170, 90, 802, 2, 24, 45, 75, 66",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 109,
            "page_label": "110"
        }
    },
    {
        "content": "45 & 75.] \n170, 90, 802, 2, 24, 45, 75, 66 \nSorting by next digit (10s place) gives: [*Notice that 802 again comes before 2 as 802 \ncomes before 2 in the previous list.] \n802, 2, 24, 45, 66, 170, 75, 90 \nSorting by most significant digit (100s place) gives: \n2, 24, 45, 66, 75, 90, 170, 802 \nWhat is the running time of Radix Sort? \nLet there be d digits in input integers. Radix Sort takes O(d*(n+b)) time where b is the \nbase for representing numbers, for example, for deci mal system, b is 10. What is the \nvalue of d? If k is the maximum possible value, then d would be O(log b(k)). So overall",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 109,
            "page_label": "110"
        }
    },
    {
        "content": "value of d? If k is the maximum possible value, then d would be O(log b(k)). So overall \ntime complexity is O((n+b) * log b(k)). Which looks more than the time complexity of \ncomparison based sorting algorithms for a large k. L et us first limit k. Let k <= n c where \nc is a constant. In that case, the complexity becomes O(nLog b(n)). But it still doesn’t \nbeat comparison based sorting algorithms. \nLinear Search \nLinear search is to check each element one by one in sequence. The follow ing \nmethod linearSearch() searches a target in an array and returns the index of the target; if",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 109,
            "page_label": "110"
        }
    },
    {
        "content": "method linearSearch() searches a target in an array and returns the index of the target; if \nnot found, it returns -1, which indicates an invalid index. \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \nint linearSearch(int arr[], int target) \n{ \n    for (int i = 0; i < arr.length; i++) \n    { \n        if (arr[i] == target) \n            return i; \n    } \n    return -1; \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 109,
            "page_label": "110"
        }
    },
    {
        "content": "Linear search loops through each element in the array; each loop body takes constant \ntime. Therefore, it runs in linear time O(n). \nLecture-31 \nBinary Search \nFor sorted arrays, binary search is more efficient than linear search. The process starts \nfrom the middle of the input array: \n If the target equals the element in the middle, return its index. \n If the target is larger than the element in the middle, search the right half. \n If the target is smaller, search the left half. \nIn the following  binarySearch() method, the two index variables  first and last indicates the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 110,
            "page_label": "111"
        }
    },
    {
        "content": "In the following  binarySearch() method, the two index variables  first and last indicates the \nsearching boundary at each round. \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \n13 \n14 \n15 \n16 \nint binarySearch(int arr[], int target) \n{ \n    int first = 0, last = arr.length - 1; \n  \n    while (first <= last) \n    { \n        int mid = (first + last) / 2;  \n        if (target == arr[mid])  \n            return mid;  \n        if (target > arr[mid]) \n            first = mid + 1; \n        else \n            last = mid - 1; \n    } \n    return -1; \n} \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 110,
            "page_label": "111"
        }
    },
    {
        "content": "last = mid - 1; \n    } \n    return -1; \n} \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \narr: {3, 9, 10, 27, 38, 43, 82} \n  \ntarget: 10 \nfirst: 0, last: 6, mid: 3, arr[mid]: 27   --  go left \nfirst: 0, last: 2, mid: 1, arr[mid]: 9    --  go right \nfirst: 2, last: 2, mid: 2, arr[mid]: 10   --  found \n  \ntarget: 40 \nfirst: 0, last: 6, mid: 3, arr[mid]: 27   --  go right \nfirst: 4, last: 6, mid: 5, arr[mid]: 43   --  go left \nfirst: 4, last: 4, mid: 4, arr[mid]: 38   --  go right \nfirst: 5, last: 4                         --  not found",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 110,
            "page_label": "111"
        }
    },
    {
        "content": "Binary search divides the array in the middle at each round of the loop. Suppose the \narray has length n and the loop runs in t rounds, then we have n * (1/2)^t = 1 since at \neach round the array length is divided by 2. Thus t = log(n). At each round, the loop \nbody takes constant time. Therefore, binary search runs in logarithmic time O(log n). \nThe following code implements binary search using recursion. To call the method, we \nneed provide with the boundary indexes, for example,  \nbinarySearch(arr, 0, arr.length - 1, target); \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \n13 \n14 \n15",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 111,
            "page_label": "112"
        }
    },
    {
        "content": "binarySearch(arr, 0, arr.length - 1, target); \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \n11 \n12 \n13 \n14 \n15 \n \nbinarySearch(int arr[], int first, int last, int target) \n{ \n    if (first > last) \n        return -1; \n  \n    int mid = (first + last) / 2; \n  \n    if (target == arr[mid])  \n        return mid; \n    if (target > arr[mid]) \n        return binarySearch(arr, mid + 1, last, target); \n    // target < arr[mid] \n    return binarySearch(arr, first, mid - 1, target); \n}",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 111,
            "page_label": "112"
        }
    },
    {
        "content": "Lecture-32 \nHashing \nIntroduction \nThe problem at hands is to speed up \nsearching. Consider the problem of \nsearching an array for a given value. If \nthe array is not sorted, the search might \nrequire examining each and all \nelements of the array. If the array is \nsorted, we can use the binary search, \nand therefore reduce the worse -case \nruntime complexity to O(log n). We \ncould search even faster if we know in \nadvance the index at which that value is \nlocated in the array. Suppose we do \nhave that magic function that would tell \nus the index for a given value. With this",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 112,
            "page_label": "113"
        }
    },
    {
        "content": "have that magic function that would tell \nus the index for a given value. With this \nmagic function our search is reduced to \njust one probe, g iving us a constant \nruntime O(1). Such a function is called \na hash function . A hash function is a \nfunction which when given a key, \ngenerates an address in the table. \n  \n   \nThe example of a hash function is a  book call number . Each book in the library has \na unique call number. A call number is like an address: it tells us where the book is \nlocated in the library. Many academic libraries in the United States, uses Library of",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 112,
            "page_label": "113"
        }
    },
    {
        "content": "located in the library. Many academic libraries in the United States, uses Library of \nCongress Classification for call numbers. This system uses a combination of letters and \nnumbers to arrange materials by subjects. \nA hash function that returns a unique hash number is called a universal hash function. \nIn practice it is extremely hard to assign unique numbers to objects. The later is always \npossible only if you know (or approximate) the number of objects to be proccessed. \nThus, we say that our hash function has the following properties \n it always returns a number for an object.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 112,
            "page_label": "113"
        }
    },
    {
        "content": " it always returns a number for an object. \n two equal objects will always have the same number \n two unequal objects not always have different numbers \nThe precedure of storing objets using a hash function is the following. \nCreate an array of size  M. Choose a hash function  h, that is a mapping from \nobjects into integers  0, 1, ..., M -1. Put these objects into an array at indexes \ncomputed via the ha sh function  index = h(object) . Such array is called a  hash \ntable.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 112,
            "page_label": "113"
        }
    },
    {
        "content": "Collisions \nWhen we put objects into a hashtable, it is possible that different objects (by \nthe equals() method) might have the same hashcode. This is called a  collision. Here is \nthe example of collision. Two different strings \"\"Aa\" and \"BB\" have the same key: . \n\"Aa\" = 'A' * 31 + 'a' = 2112  \n\"BB\" = 'B' * 31 + 'B' = 2112 \n  \n   \nHow to resolve collisions? Where do we put \nthe second and subsequent values that hash \nto this same location? There are several \napproaches in dealing with collisions. One of \nthem is based on idea of putting the keys that",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 113,
            "page_label": "114"
        }
    },
    {
        "content": "approaches in dealing with collisions. One of \nthem is based on idea of putting the keys that \ncollide in a linked list! A hash table then is an \narray of lists!! This technique is called \na separate chaining collision resolution. \nThe big attraction o f using a hash table is a constant -time performance for the basic \noperations add, remove, contains, size. Though, because of collisions, we cannot guarantee \nthe constant runtime in the worst-case. Why? Imagine that all our objects collide into the \nsame index. Then searching for one of them will be equivalent to searching in a list, that",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 113,
            "page_label": "114"
        }
    },
    {
        "content": "same index. Then searching for one of them will be equivalent to searching in a list, that \ntakes a liner runtime. However, we can guarantee an expected constant runtime, if we \nmake sure that our lists won't become too long. This is usually implemnted by \nmaintaining a load factor that keeps a track of the average length of lists. If a load factor \napproaches a set in advanced threshold, we create a bigger array and  rehash all \nelements from the old table into the new one. \nAnother technique of collision resolution is a  linear probing. If we cannoit insert at index",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 113,
            "page_label": "114"
        }
    },
    {
        "content": "Another technique of collision resolution is a  linear probing. If we cannoit insert at index \nk, we try the next slot k+1. If that one is occupied, we go to k+2, and so on.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 113,
            "page_label": "114"
        }
    },
    {
        "content": "Lecture-33 \nHashing Functions \nChoosing a good hashing function,  h(k), is essential for hash -table based \nsearching. h should distribute the elements of our collection as uniformly as possible to \nthe \"slots\" of the hash table. The key criterion is that there should be a minimum \nnumber of collisions. \nIf the probability that a key, k, occurs in our collection is P(k), then if there are m slots in \nour hash table, a uniform hashing function, h(k), would ensure: \n \nSometimes, this is easy to ensure. For example, if the keys are randomly distributed in \n(0,r], then, \nh(k) = floor((mk)/r)",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 114,
            "page_label": "115"
        }
    },
    {
        "content": "(0,r], then, \nh(k) = floor((mk)/r) \nwill provide uniform hashing. \nMapping keys to natural numbers \nMost hashing functions will first map the keys to some set of natural numbers, say (0,r]. \nThere are many ways to do this, for example if the key is a string of ASCII characters, \nwe can simply add the ASCII representations of the characters mod 255 to  produce a \nnumber in (0,255) - or we could xor them, or we could add them in pairs mod 2 16-1, or \n... \nHaving mapped the keys to a set of natural numbers, we then have a number of \npossibilities. \n1. Use a mod function: \nh(k) = k mod m.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 114,
            "page_label": "115"
        }
    },
    {
        "content": "possibilities. \n1. Use a mod function: \nh(k) = k mod m. \nWhen using this method, we usually avoid certain values of  m. Powers of 2 are \nusually avoided, for k mod 2b simply selects the b low order bits of  k. Unless we \nknow that all the 2 b possible values of the lower order bits are equally likely, this \nwill not be a good choice, because so me bits of the key are not used in the hash \nfunction. \nPrime numbers which are close to powers of 2 seem to be generally good \nchoices for m. \nFor example, if we have 4000 elements, and we have chosen an overflow table",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 114,
            "page_label": "115"
        }
    },
    {
        "content": "choices for m. \nFor example, if we have 4000 elements, and we have chosen an overflow table \norganization, but wish to have the proba bility of collisions quite low, then we \nmight choose m = 4093. (4093 is the largest prime less than 4096 = 212.) \n2. Use the multiplication method: \no Multiply the key by a constant A, 0 < A < 1, \no Extract the fractional part of the product, \no Multiply this value by m. \nThus the hash function is: \nh(k) = floor(m * (kA - floor(kA)))",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 114,
            "page_label": "115"
        }
    },
    {
        "content": "In this case, the value of m is not critical and we typically choose a power of 2 so \nthat we can get the following efficient procedure on most digital computers: \no Choose m = 2p. \no Multiply the w bits of k by floor(A * 2w) to obtain a 2w bit product. \no Extract the p most significant bits of the lower half of this product. \nIt seems that: \nA = (sqrt(5)-1)/2 = 0.6180339887 \nis a good choice ( see Knuth, \"Sorting and Searching\", v. 3 of \"The Art of \nComputer Programming\"). \n3. Use universal hashing: \nA malicious adversary can always chose the keys so that they all hash to the",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 115,
            "page_label": "116"
        }
    },
    {
        "content": "A malicious adversary can always chose the keys so that they all hash to the \nsame slot, leading to an average  O(n) retrieval time. Universal hashing seeks to \navoid this by choosing the hashing function randomly from a collection of hash \nfunctions ( cf Cormen et al , p 229 - ). This makes the probability that the hash \nfunction will generate poor behaviour small and produces good average \nperformance.",
        "metadata": {
            "producer": "www.ilovepdf.com",
            "creator": "Microsoft® Word 2016",
            "creationdate": "2018-07-20T08:39:03+00:00",
            "author": "SANTOSH",
            "moddate": "2018-07-20T08:39:04+00:00",
            "source": "notes/dsa_book.pdf",
            "total_pages": 116,
            "page": 115,
            "page_label": "116"
        }
    }
]